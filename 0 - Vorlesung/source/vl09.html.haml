---
title: Vorlesung 9 - NodeJS
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule für angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils Löwe / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \## 3. Praktikum
  [Praktikum 3: Architekturentwurf](https://ai2016.nils-loewe.de/p03.html)
  \### Fragen?

%section{"data-markdown" => ""}
  \## 4. Praktikum
  \#### Frage: Alle Präsentationen in der 12. Vorlesungswoche?
  \### JA

%section{"data-markdown" => ""}
  \## Wiederholung

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme

%section{"data-markdown" => ""}
  \### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section{"data-markdown" => ""}
  \### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \### Adaptive Systeme
  \#### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### Nutzen von Templates

  Beispiele:
  * arc42
  * Normen
  * Software Guidebook

%section{"data-markdown" => ""}
  \### ARC42
  \#### (Dr. Gernot Starke / Dr. Peter Hruschka)
  http://www.arc42.de/

  \#### *arc42 unterstützt Software- und Systemarchitekten. Es kommt aus der Praxis und basiert auf Erfahrungen internationaler Architekturprojekte und Rückmeldungen vieler Anwender.*

%section{"data-markdown" => ""}
  \### IEEE Standards - Kosten

  * IEEE 830: 171$
  * Journals: 26.500$ / Jahr
  * Standards Library: *custom quote*

%section{"data-markdown" => ""}
  \### Software Guidebook

  \#### Welche Informationen wünsche ich mir, wenn ich in ein neues Projekt komme?

  * Karten
  * Sichten
  * Geschichte
  * Praktische Informationen!

%section{"data-markdown" => ""}
  \### Software Guidebook
  \## Product vs project documentation

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Frameworks
  \## Was ist ein Framework?

%section{"data-markdown" => ""}
  \### Frameworks

  \### Ein Framework ist kein fertiges Programm, es stellt einen Rahmen zur Verfügung.

%section{"data-markdown" => ""}
  \### Frameworks

  * Ein Framework ist eine semi-vollständige Applikation.
  * Es stellt für Applikationen eine wiederverwendbare, gemeinsame Struktur zur Verfügung.
  * Entwickler integrieren dass Framework in ihre eigene Applikation ein, und erweitern es um die Applikationslogik.
  * Frameworks stellen eine kohärente Struktur zur Verfügung, anstatt eine einfache Menge von Hilfsklassen anzubieten.

%section{"data-markdown" => ""}
  \### Frameworks

  * Ein Framework gibt in der Regel die Anwendungsarchitektur vor.
  * Ein Framework definiert den Kontrollfluss der Anwendung
  * Ein Framework definierte die Schnittstellen für die Applikation.

%section{"data-markdown" => ""}
  \### Frameworks

  \### Eine allgemeingültige Definition von Frameworks gibt es aufgrund der hohen Anzahl von Diversitäten nicht.

%section{"data-markdown" => ""}
  \### Frameworks

  \## Vorteile

  * Wiederverwendung von Code
  * Grundfunktionalität muss nicht immer wieder implementiert werden
  * Es existieren genormte Schnittstellen z.B. zu Datenbanken
  * Frameworks erleichtern die Programmierarbeit und sparen Entwicklungszeit
  * Frameworks können den Stil entscheidend verbessern

%section{"data-markdown" => ""}
  \### Frameworks

  \## Nachteile
  * Frameworks erhöhen die Komplexität der Anwendung
  * Frameworks stecken voller Know-How und eine effiziente Anwendung erfordert Profiwissen
  * Frameworks nehmen nicht das Verständnis der Grundlagen ab, auch wenn oft so gearbeitet wird
  * Dokumentationen sind größtenteils unzureichend

%section{"data-markdown" => ""}
  \### Frameworks
  Wie wähle ich ein Framework aus?


%section{"data-markdown" => ""}
  \###	Popularität und Community
  *Wie wahrscheinlich finde ich Hilfe und Entwickler?*

%section{"data-markdown" => ""}
  \### Philosophie
  *A tool developed by professionals for their own needs will obviously meet the demands of other professionals.*

%section{"data-markdown" => ""}
  \### Sustainability / Nachhaltigkeit
  *Kann das Framework "mitwachsen"?*

%section{"data-markdown" => ""}
  \### Support
  *Gibt es professionelle Hilfe neben der Community?*

%section{"data-markdown" => ""}
  \### Technik
  *Wie gut ist das Framework implementiert?*

%section{"data-markdown" => ""}
  \### Security
  *Wie schnell werden Sicherheitslücken reportet und geschlossen?*

%section{"data-markdown" => ""}
  \### Dokumentation
  *Wie gut, ausführlich und verständlich ist das Framework dokumentiert? Wie aktuell ist die Doku?*

%section{"data-markdown" => ""}
  \### Lizenz
  *Ein Framework unter GPL Lizenz verlangt z.B., dass die Anwendung auch unter der GPL steht. MIT dagegen nicht.*

%section{"data-markdown" => ""}
  \### Entwickler-Kapazität
  *Wie wahrscheinlich werde ich Entwickler finden?*

%section{"data-markdown" => ""}
  \### Hosting Requirements
  *Wie einfach kann ich die Anwendung deployen?*

%section{"data-markdown" => ""}
  \### Einfache Installation?
  *Wie schnell ist ein neues Projekt eingerichtet?*

%section{"data-markdown" => ""}
  \### Lernkurve
  *Wie komplex ist das Framework?*

%section{"data-markdown" => ""}
  \### Inhalte / Funktionen?

  * AJAX
  * Authentication
  * Authorization
  * Caching
  * Data Validation
  * Templating engine
  * URL mapping / rewriting
  * ...?

%section{"data-markdown" => ""}
  \### DB Abstraktion / ORM
  *Wie einfach/mächtig ist das Object Relational Mapping?*

%section{"data-markdown" => ""}
  \### JS Library
  *Welche JS Bibliothek ist per default dabei?*

%section{"data-markdown" => ""}
  \### Unit Testing
  *Wie sehr ist TDD Teil der Philosophie, wie ist der Tool-Support?*

%section{"data-markdown" => ""}
  \### Skalierbarkeit?
  *Wie einfach lässt sich die Anwendung bei Bedarf skalieren?*

%section{"data-markdown" => ""}
  \### Ausprobieren!
  *Reviews lesen reicht nicht, Erfahrungen und das look&feel zählen!*

%section{"data-markdown" => ""}
  \### Wann brauche ich ein Framework?

  * Die Anwendung basiert im Wesentlichen auf CRUD Operationen
  * Die Anwendung wird relativ groß
  * UI und Anwendungslogik sollen getrennt werden
  * Authentication und andere Grundfunkionen werden intensiv genutzt
  * Zeitdruck + Das Framework ist bereits bekannt

%section{"data-markdown" => ""}
  \### Wann brauche ich KEIN Framework?

  * Ich brauche nur einen kleinen Teil des Frameworks (z.B. ORM)
  * Zeitdruck + Das Framework ist nicht bekannt
  * "Frameworks lösen jedes Problem"

%section{"data-markdown" => ""}
  \### Fragen?


%section{"data-markdown" => ""}

  \### Ruby on Rails
  \#### Spring Boot (moovel Group GmbH)
  \####  NodeJS
  \#### AMQP
  \#### Docker (Akra GmbH)
  \#### AngularJS
  \#### Microservices (Wer liefert was GmbH)
  \#### Twitter Bootstrap

%section{"data-markdown" => ""}
  \## Ruby on Rails

%section{"data-markdown" => ""}
  \#### Ruby on Rails
  \### Ruby: Überblick

  * Erste Version 1993
  * Verbreitet seit 2006 (durch Rails)
  * Objektorientiert
  * Interpretiert
  * Dynamisch getypt
  * "Script Sprache"

%section{"data-markdown" => ""}
  \#### Ruby on Rails
  \### Ruby: Tradeoffs

  * Flexibilität vs. Sicherheit
  * Laufzeit-Effizienz vs. Produktivität

%section{"data-markdown" => ""}
  \#### Ruby on Rails: Geschichte

  * 2004: Entwickelt als Basis für *Basecamp*
  * Version 1.0 (2005)
  * Version 1.1 (2006) - Scripting Engines, Performance
  * Version 1.2 (2007) - REST Support, MIME-type routing, UTF-8
  * Version 2.0 (2007) - REST als Default
  * Version 2.1 (2008) - Named Scopes, Migrationen mit Timestamp
  * Version 2.2 (2008) - Internationalisierung, Threadsicherheit
  * Version 2.3 (2009) - Template Engine
  * Version 3.0 (2010) - Modularisierung: Einzelne Teile verwendbar
  * Version 3.1 (2011) - Asset Pipeline
  * Version 4.0 (2013)
  * Version 5.0 (2016)

%section{"data-markdown" => ""}
  \#### Ruby on Rails: Bestandteile

  * Active Support: Ruby-Erweiterungen von Rails
  * Active Record: Objektabstraktionsschicht (ORM)
  * Action Pack: Request-Behandlung und Response-Ausgabe.
  * Action View: Templates
  * Action Mailer: E-Mail-Versand und -Empfang
  * Active Resource: Routing, REST, XML-RPC

%section{"data-markdown" => ""}
  \#### Ruby on Rails: Grundlagen

  * Basiert auf Ruby
  * Model-View-Controller Architektur
  * „Don’t repeat yourself“
  * „Convention over Configuration“
  * Scaffolding
  * Datenbankmigrationen

%section{"data-markdown" => ""}
  \#### Ruby on Rails: Grundlagen
  \### „Don’t repeat yourself“

  * Jede Information sollte nur ein einziges Mal vorhanden sein
  * z.B. ActiveRecord liest das DB-Scheme direkt aus der DB
  * z.B. Rails erstellt für das Model automatisch Getter- und Setter-Methoden
  * Vorteil: Informationen werden nicht inkonsistent wenn eine Stelle verändert wird


%section{"data-markdown" => ""}
  \#### Ruby on Rails: Grundlagen
  \### „Convention over configuration“

  * Rails erwartet sinnvolle Standardwerte
  * --> z.B. Primärschlüssel einer Tabelle ist ID vom Typ Integer
  * --> ein Modell mit dem Namen Customer liegt in der Datei \#{Rails.root}/app/models/customer.rb
  * --> Die zugehörige Tabelle heißt customers heißt

%section{"data-markdown" => ""}
  \#### Ruby on Rails: Grundlagen
  \### Scaffolding

  * Es gibt Generatoren für alle Standardfälle
  * Models, Controller, Views, Mailer, Migrationen, ...
  * Konventionen werden eingehalten
  * Web-Anwendungen lassen sich sehr schnell entwickeln
  * Wenn in der Datenbank etwa ein Feld hinzugefügt wird, erscheint es auch sofort in der entsprechenden View/New/Edit-Ansicht.
  * Scaffolding ist vor allem für Prototyping gedacht

%section{"data-markdown" => ""}
  \### Fragen?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben

  * Was waren die Gründe für Softwarearchitektur?
  * Was sollte eine Kontext-Sicht enthalten?
  * In welcher Beziehung stehen Architektur und Design?
  * Was besagt 'Conways Law'?
  * Nennen und erläutern Sie drei Arten von Architekturmustern
  * Für welche Systeme wird das MVC Muster typischerweise verwendet?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \### Technologien und Frameworks

%section{"data-markdown" => ""}

  \#### Ruby on Rails
  \#### Spring Boot (moovel Group GmbH)
  \###  NodeJS
  \#### AMQP
  \#### Docker (Akra GmbH)
  \#### AngularJS
  \#### Microservices (Wer liefert was GmbH)
  \#### Twitter Bootstrap

%section{"data-markdown" => ""}
  \### NodeJS

  The Node.js project maintains multiple types of releases:

  Current: Released from active development branches of this repository, versioned by SemVer and signed by a member of the Release Team. Code for Current releases is organized in this repository by major version number, For example: v4.x. The major version number of Current releases will increment every 6 months allowing for breaking changes to be introduced. This happens in April and October every year. Current release lines beginning in October each year have a maximum support life of 8 months. Current release lines beginning in April each year will convert to LTS (see below) after 6 months and receive further support for 30 months.
  LTS: Releases that receive Long-term Support, with a focus on stability and security. Every second Current release line (major version) will become an LTS line and receive 18 months of Active LTS support and a further 12 months of Maintenance. LTS release lines are given alphabetically ordered codenames, beginning with v4 Argon. LTS releases are less frequent and will attempt to maintain consistent major and minor version numbers, only incrementing patch version numbers. There are no breaking changes or feature additions, except in some special circumstances. More information can be found in the LTS README.
  Nightly: Versions of code in this repository on the current Current branch, automatically built every 24-hours where changes exist. Use with caution.

  2009.06.11, Version 0.0.3
  59 unstable Releases
  2011.09.15, Version 0.4.12 (stable)
  2011.10.21, Version 0.5.10 (unstable)
  2012.07.10 Version 0.6.20 (maintenance)
  2012.06.19, Version 0.7.12 (unstable)
  2013.06.13, Version 0.8.25 (maintenance)
  2013.03.06, Version 0.9.12 (Unstable)
  2013.03.11, Version 0.10.0 (Stable)
  2016-05-05, Version 4.4.4 (LTS)

%section{"data-markdown" => ""}
  ![](/images/node_schedule.png)

  What is Node.js?
  Node.js is a server side platform built on Google Chrome's JavaScript Engine (V8 Engine). Node.js was developed by Ryan Dahl in 2009 and its latest version is v0.10.36. The definition of Node.js as supplied by its official documentation is as follows −

  Node.js is a platform built on Chrome's JavaScript runtime for easily building fast and scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.

%section{"data-markdown" => ""}
  https://github.com/nodejs/node

%section{"data-markdown" => ""}
  Chrome V8
  Google's high performance, open source, JavaScript engine.
  V8 is Google's open source high-performance JavaScript engine, written in C++ and used in Google Chrome, the open source browser from Google. It implements ECMAScript as specified in ECMA-262, 3rd edition, and runs on Windows XP or later, Mac OS X 10.5+, and Linux systems that use IA-32, ARM or MIPS processors. V8 can run standalone, or can be embedded into any C++ application.


%section{"data-markdown" => ""}
  Node.js is an open source, cross-platform runtime environment for developing server-side and networking applications. Node.js applications are written in JavaScript, and can be run within the Node.js runtime on OS X, Microsoft Windows, and Linux.

  Node.js also provides a rich library of various JavaScript modules which simplifies the development of web applications using Node.js to a great extent.

  Node.js = Runtime Environment + JavaScript Library

%section{"data-markdown" => ""}
  Features of Node.js
  Following are some of the important features that make Node.js the first choice of software architects.

  Asynchronous and Event Driven All APIs of Node.js library are asynchronous that is, non-blocking. It essentially means a Node.js based server never waits for an API to return data. The server moves to the next API after calling it and a notification mechanism of Events of Node.js helps the server to get a response from the previous API call.

  Very Fast Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.

  Single Threaded but Highly Scalable - Node.js uses a single threaded model with event looping. Event mechanism helps the server to respond in a non-blocking way and makes the server highly scalable as opposed to traditional servers which create limited threads to handle requests. Node.js uses a single threaded program and the same program can provide service to a much larger number of requests than traditional servers like Apache HTTP Server.

  No Buffering - Node.js applications never buffer any data. These applications simply output the data in chunks.

  License - Node.js is released under the MIT license.

%section{"data-markdown" => ""}
  Who Uses Node.js?
  Following is the link on github wiki containing an exhaustive list of projects, application and companies which are using Node.js. This list includes eBay, General Electric, GoDaddy, Microsoft, PayPal, Uber, Wikipins, Yahoo!, and Yammer to name a few.

%section{"data-markdown" => ""}
  Concepts
  The following diagram depicts some important parts of Node.js which we will discuss in detail in the subsequent chapters.

%section{"data-markdown" => ""}
  ![](/images/nodejs_concepts.jpg)

%section{"data-markdown" => ""}
  Where to Use Node.js?
  Following are the areas where Node.js is proving itself as a perfect technology partner.

  I/O bound Applications

  Data Streaming Applications

  Data Intensive Real time Applications (DIRT)

  JSON APIs based Applications

  Single Page Applications

%section{"data-markdown" => ""}
  Where Not to Use Node.js?
  It is not advisable to use Node.js for CPU intensive applications.

%section{"data-markdown" => ""}

  * Install the Distro-Stable Version (linux, MacOS)
  * Install Using NVM (linux, MacOS)
  * Install from source/tar (linux, MacOS, Windows, FreeBSD, OpenBSD, AIX, ARM, ...)

%section{"data-markdown" => ""}
  REPL stands for Read Eval Print Loop and it represents a computer environment like a window console or Unix/Linux shell where a command is entered and system responds with an output in interactive mode. Node.js or Node comes bundled with a REPL environment. It performs the following desired tasks.

  Read - Reads user's input, parse the input into JavaScript data-structure and stores in memory.

  Eval - Takes and evaluates the data structure

  Print - Prints the result

  Loop - Loops the above command until user press ctrl-c twice.

  REPL feature of Node is very useful in experimenting with Node.js codes and to debug JavaScript codes.

  REPL can be started by simply running node on shell/console without any argument as follows.

  $ node
  You will see the REPL Command prompt > where you can type any Node.js command:

  $ node
  >

%section{"data-markdown" => ""}
  REPL Commands
  ctrl + c - terminate the current command.

  ctrl + c twice - terminate the Node REPL.

  ctrl + d - terminate the Node REPL.

  Up/Down Keys - see command history and modify previous commands.

  tab Keys - list of current commands.

  .help - list of all commands.

  .break - exit from multiline expression.

  .clear - exit from multiline expression

  .save filename - save current Node REPL session to a file.

  .load filename - load file content in current Node REPL session.


%section{"data-markdown" => ""}
  https://www.npmjs.com/
  The current stable version of npm is 3.9.0
  $ npm --version
  2.7.1
  sudo npm install npm -g

%section{"data-markdown" => ""}

  npm is the package manager for JavaScript. Find, share, and reuse packages of code from hundreds of thousands of developers — and assemble them in powerful new ways.
  3 million developers and thousands of companies use npm

%section{"data-markdown" => ""}

  283,432
  total packages

  packages icon
  57,724,266
  downloads in the last day

  packages icon
  1,040,776,238
  downloads in the last week

  packages icon
  4,169,158,104
  downloads in the last month


%section{"data-markdown" => ""}
  npm Enterprise is priced per user, per month. Just pick the level of support that’s right for you.

  $7
  per user / month


  Orgs
  Your own restricted scope for private code
  Hosted by npm
  For teams that don't need advanced features
  Learn more
  $16
  per user / month

  npm
  Enterprise
  Bring the open-source toolkit into your company
  Host on your server
  Online support from npm’s team
  Get started
  from $2000
  per year

  npm
  Enterprise Pro
  Enterprise-grade support for large teams
  Dedicated account management and support
  Additional customization options

%section{"data-markdown" => ""}

  npm is free for public projects
  Share private packages with our paid plans, starting at just $7/mo.
  Security for your Private Code
  Publish and control access to @org-name/foo
  Unlimited number of packages
  It's better to build with many blocks; not one. Some teams have thousands of private packages.

%section{"data-markdown" => ""}

  For individuals looking to collaborate with other npm Private Package developers

  Unlimited public & private packages
  $7/month
  Includes one scope name, based on user name
  Publish and control access to @user-name/foo

  Using a package.json

  The best way to manage locally installed npm packages is to create a package.json file.

  A package.json file affords you a lot of great things:

  It serves as documentation for what packages your project depends on.
  It allows you to specify the versions of a package that your project can use using semantic versioning rules.
  Makes your build reproducable which means that its way easier to share with other developers.
  Requirements

  As a bare minimum, a package.json must have:

  "name"
  all lowercase
  one word, no spaces
  dashes and underscores allowed
  "version"
  For example:

  {
  "name": "my-awesome-package",
  "version": "1.0.0"
  }

  Attributes of Package.json
  name - name of the package

  version - version of the package

  description - description of the package

  homepage - homepage of the package

  author - author of the package

  contributors - name of the contributors to the package

  dependencies - list of dependencies. npm automatically installs all the dependencies mentioned here in the node_module folder of the package.

  repository - repository type and url of the package

  main - entry point of the package

  keywords - keywords


%section{"data-markdown" => ""}
  Create a module
  Creation of module requires package.json to be generated. Let's generate package.json using npm, which will generate basic skeleton of the package.json.

  $ npm init
  This utility will walk you through creating a package.json file.
  It only covers the most common items, and tries to guess sane defaults.

  See 'npm help json' for definitive documentation on these fields
  and exactly what they do.

  Use 'npm install <pkg> --save' afterwards to install a package and
  save it as a dependency in the package.json file.

  Press ^C at any time to quit.
  name: (webmaster)
  You will need to provide all the required information about your module. YOu can take help from the above mentioned package.json file to understand the meanings of various information demanded. Once package.json is generated. Use the following command to register yourself with npm repository site using a valid email address.

  $ npm adduser
  Username: mcmohd
  Password:
  Email: (this IS public) mcmohd@gmail.com
  Now its time to publish your module:

  $ npm publish
  If everything is fine with your module, then it will be published in the reporsitory and will be accessible to install using npm like any other other Node.js module.

%section{"data-markdown" => ""}
  What is Callback?
  Callback is an asynchronous equivalent for a function. A callback function is called at the completion of a given task. Node makes heavy use of callbacks. All APIs of Node are written is such a way that they supports callbacks.

  For example, a function to read a file may start reading file and return the control to execution environment immidiately so that next instruction can be executed. Once file I/O is complete, it will call the callback function while passing the callback function, the content of the file as parameter. So there is no blocking or wait for File I/O. This makes Node.js highly scalable, as it can process high number of request without waiting for any function to return result.

  Blocking Code Example
  Create a text file named input.txt having following content

  Tutorials Point is giving self learning content
  to teach the world in simple and easy way!!!!!
  Create a js file named main.js which has the following code:

  var fs = require("fs");

  var data = fs.readFileSync('input.txt');

  console.log(data.toString());
  console.log("Program Ended");
  Now run the main.js to see the result:

  $ node main.js
  Verify the Output

  Tutorials Point is giving self learning content
  to teach the world in simple and easy way!!!!!
  Program Ended
  Non-Blocking Code Example
  Create a text file named input.txt having following content

  Tutorials Point is giving self learning content
  to teach the world in simple and easy way!!!!!
  Update main.js file to have following code:

  var fs = require("fs");

  fs.readFile('input.txt', function (err, data) {
  if (err) return console.error(err);
  console.log(data.toString());
  });

  console.log("Program Ended");
  Now run the main.js to see the result:

  $ node main.js
  Verify the Output

  Program Ended
  Tutorials Point is giving self learning content
  to teach the world in simple and easy way!!!!!
  These two examples explain the concept of blocking and non-blocking calls. First example shows that program blocks until it reads the file and then only it proceeds to end the program where as in second example, program does not wait for file reading but it just proceeded to print "Program Ended" and same time program without blocking continues reading the file.

  Thus, a blocking program executes very much in sequence and from programming point of view its easier to implement the logic but non-blocking programs does not execute in sequence, so in case a program needs to use any data to be processed, it should be kept with-in the same block to make it sequential execution.

%section{"data-markdown" => ""}
  Node js is a single threaded application but it support concurrency via concept of event and callbacks. As every API of Node js are asynchronous and being a single thread, it uses async function calls to maintain the concurrency. Node uses observer pattern. Node thread keeps an event loop and whenever any task get completed, it fires the corresponding event which signals the event listener function to get executed.

  Event Driven Programming
  Node.js uses events heavily and it is also one of the reasons why Node.js is pretty fast compared to other similar technologies. As soon as Node starts its server, it simply initiates its variables, delcares functions and then simply waits for event to occur.

  In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected.

%section{"data-markdown" => ""}
  ![](/images/event_loop.jpg)

%section{"data-markdown" => ""}
  Event Loop
  While Events seems similar to what callbacks are. The difference lies in the fact that callback functions are called when an asynchronous function returns its result where as event handling works on the observer pattern. The functions which listens to events acts as Observers. Whenever an event gets fired, its listener function starts executing. Node.js has multiple in-built events available through events module and EventEmitter class which is used to bind events and event listeners as follows:

  // Import events module
  var events = require('events');

  // Create an eventEmitter object
  var eventEmitter = new events.EventEmitter();
  Following is the syntax to bind event handler with an event:

  // Bind event and even handler as follows
  eventEmitter.on('eventName', eventHandler);
  We can fire an event programatically as follows:

  // Fire an event
  eventEmitter.emit('eventName');
%section{"data-markdown" => ""}
  Many objects in Node emit events for example a net.Server emits an event each time a peer connects to it, a fs.readStream emits an event when the file is opened. All objects which emit events are instances of events.EventEmitter.

  EventEmitter Class
  As we have seen in previous section, EventEmitter class lies in events module. It is accessibly via following syntax:

  // Import events module
  var events = require('events');
  // Create an eventEmitter object
  var eventEmitter = new events.EventEmitter();
  When an EventEmitter instance faces any error, it emits an 'error' event. When new listener is added, 'newListener' event is fired and when a listener is removed, 'removeListener' event is fired.

  EventEmitter provides multiple properties like on and emit. on property is used to bind a function with the event and emit is used to fire an event.
%section{"data-markdown" => ""}
  What are Streams?
  Streams are objects that let you read data from a source or write data to a destination in continous fashion. In Node.js, there are four types of streams.

  Readable - Stream which is used for read operation.

  Writable - Stream which is used for write operation.

  Duplex - Stream which can be used for both read and write operation.

  Transform - A type of duplex stream where the output is computed based on input.

  Each type of Stream is an EventEmitter instance and throws several events at different instance of times. For example, some of the commonly used events are:

  data - This event is fired when there is data is available to read.

  end - This event is fired when there is no more data to read.

  error - This event is fired when there is any error receiving or writing data.

  finish - This event is fired when all data has been flushed to underlying system

  This tutorial will give you understanding on commonly used operations on Streams.


%section{"data-markdown" => ""}
  Node.js - File System
  Node implements File I/O using simple wrappers around standard POSIX functions. Node File System (fs) module can be imported using following syntax:

  var fs = require("fs")
  Synchronous vs Asynchronous
  Every method in fs module have synchronous as well as asynchronous form. Asynchronous methods takes a last parameter as completion function callback and first parameter of the callback function is error. It is preferred to use asynchronous method instead of synchronous method as former never block the program execution where as the second one does.

%section{"data-markdown" => ""}
  There are number of utility modules available in Node.js module library. These modules are very common and are frequently used while developing any Node based applications.

  S.N.	Module Name & Description
  1	OS Module
  Provides basic operating-system related utility functions.
  2	Path Module
  Provides utilities for handling and transforming file paths.
  3	Net Module
  Provides both servers and clients as streams. Acts as a network wrapper.
  4	DNS Module
  Provides functions to do actual DNS lookup as well as to use underlying operating system name resolution functionalities.
  5	Domain Module
  Provides way to handle multiple different I/O operations as a single group.

%section{"data-markdown" => ""}
  Node.js provides http module which can be used to create either HTTP client of server.

%section{"data-markdown" => ""}
  Express Overview
  Express is a minimal and flexible Node.js web application framework that provides a robust set of features to develop web and mobile applications. It facilitates a rapid development of Node based Web applications. Following are some of the core features of Express framework:

  Allows to set up middlewares to respond to HTTP Requests.

  Defines a routing table which is used to perform different action based on HTTP Method and URL.

  Allows to dynamically render HTML Pages based on passing arguments to templates.


%section{"data-markdown" => ""}
  Node.js code is open and ready to be copied like any other Javascript code. But now you can compile your Node.js code into binary and distribute it. JXcore which is an open source project, introduces a unique feature for packaging and encryption of source files and other assets into JX packages.

  Consider you have a large project consisting of many files. JXcore is very much able to pack them all into a single file to simplify the distribution. This tutorial will give you a quick overview about the whole process starting from installing JXcore.

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben

  * Was sind zwei Grundprinzipien, die hinter Ruby on Rails stecken?
  * Nennen sie drei Nachteile für die Verwendung von Frameworks!
  * Wann ist die Verwendung eines Frameworks nicht sinnvoll?
  * Nennen sie drei Auswahlkriterien für Frameworks!
  * Für welche Systeme wird das MVC Architekturmuster typischerweise verwendet?
  * Wie ist das ARC42 Template entstanden?

%section{"data-markdown" => ""}
  \## Fragen?

  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
