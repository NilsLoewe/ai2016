---
title: Vorlesung 8 - Dokumentation
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule für angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils Löwe / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \## 3. Praktikum
  [Praktikum 3: Architekturentwurf](https://ai2016.nils-loewe.de/p03.html)
  \### Fragen?

%section{"data-markdown" => ""}
  \## 4. Praktikum
  Frage: Alle Präsentationen in der 12. Vorlesungswoche?

%section{"data-markdown" => ""}
  \## Wiederholung

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \##### Adaptive Systeme
  \### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Ziel: Änderung von Systemanforderungen zur Laufzeit dynamisch begegnen.

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Aufgaben
  * Der Mikrokernel bietet die Basis für mögliche Erweiterungen
  * Der Microkernel koordiniert die Zusammenarbeit.

%section{"data-markdown" => ""}
  \#### Microkernel
  \### Herausforderung

  ![](/images/microkernel.png)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Microkernel

  * Minix Kernel
  * GNU Mach
  * AmigaOS
  * SymbianOS

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Monolithische Kernels

  * Linux
  * Android
  * Windows bis Win98 (DOS Kernel)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Hybrid-Kernels

  * MacOS X (Darwin)
  * Windows NT (oft als Microkernel bezeichnet)


%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Vorteile

  * Separierte Komponenten: Austauschbarkeit
  * Treiber im Benutzer-Modus: Sicherheit
  * kleine Trusted Computing Base
  * Skalierbarkeit
  * Zuverlässigkeit
  * Transparenz

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Nachteile

  * Leistung
  * Komplexität

%section{"data-markdown" => ""}
  \### Domain Driven Design
  \## Ein Beispiel

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Eine Firma bietet Softwareentwicklung als Dienstleistung an.

  \###### http://blog.mirkosertic.de/architecturedesign/dddexample

  * Aufwand wird nach Stunden verrechnet
  * Es gibt festangestellte Softwareentwickler
  * Es gibt einen Pool von Freelancern.
  * Bisher wird die Zuordnung von Entwicklern zu Projekten in einem Excel-Sheet organisiert


%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Probleme mit dem Excel-Ansatz

  * Excel skaliert nicht auf mehrere Anwender
  * Keine Sicherheit
  * Kein Logging

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel
  \### Lösung: Neue Software bauen

  * Durchsuchbarer Katalog von Freelancern
  * Mehrere Kontaktmöglichkeiten pro Freelancer
  * Durchsuchbarer Katalog von Projekten
  * Durchsuchbarer Katalog von Projekten
  * Timesheets für jeden Freelancer (pro Projekt)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddfirstrun.png)

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz
  \### Probleme?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Großer Objektgraph: Performance Probleme unter Last
  Framework wie Hibernate wäre notwendig um das zu vermeiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Warum die bidirektionale Verknüpfung zwischen User und Rolle?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Boolean-Flags um den Kontakttypen zu unterscheiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Projekt-Liste in der Freelancer-Klasse:
  \#### Freelancer verändern um Projekte zuzufügen
  Potentielle Transaktionsprobleme unter Last (mehrere Leute legen gleichzeitig Projekte für den gleichen Kunden an)

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  * Kontaktinformation == Kommunikationskanal?
  * Das Diagramm ist eher ein Entiy-Relationship-Diagram als ein Software Modell
  * Wo ist die Businesslogik?

%section{"data-markdown" => ""}
  \#### DDD nutzen
  \#### Anforderungen: "Body Leasing Domain"
  \### **Context-Map: Komplexität reduzieren durch Subdomains**

  * Identität und Access Management Subdomain
  * Freelancer Management Subdomain
  * Kundenmanagement Subdomain
  * Projektmanagement Subdomain

%section{"data-markdown" => ""}
  \#### DDD - Context Map
  ![](/images/dddcontextmap.png)

%section{"data-markdown" => ""}
  \#### DDD - Bounded Context

  * Zuordnen von Subdomains zu Teilen der Lösung
  * *Building blocks* nutzen (Design Pattern anwenden)
  * Die DDD Architekturpattern sind nicht technologieabhängig!

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Jeder Bounded Context enthält Aggregates und Wertobjekte
  * Aggregates sind Objekthierarchien
  * Nur das Root-Objekt eines Aggregates ist von außen zugreifbar
  * Jeder Zugriff auf ein Objekt passiert durch die Aggregates: Bessere Kapselung
  * Aggregates und Entites besitzen eine ID
  * Wertobjekte haben keine ID und können ihren Zustand nicht ändern
  * Jede Zustandsänderung erzeugt ein neues Wertobjekt: Vermeiden von Seiteneffekten

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Persistenz in DDD wird mit "Repositories" umgesetet
  * Ein Repository ist durchsuchbar, kann Instanzen liefern und löschen, sowie neue Instanzen ablegen
  * Es sollte ein Repository für jedes Aggregate geben

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Ein Client ist ein abstraktes Konzept
  * Ein Client kann alles von einem Frontend über einen SOAP Webservice zu einer REST Ressource sein
  * Ein Client sendet Befehle an den ApplciationService

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Der ApplicationService setzt die Befehle in UseCases um
  * Der FreelancerApplicationService lädt dasFreelancer Aggregate aus dem FreelancerRepository und ruft moveTo() auf dem FreelancerAggregate auf
  * Der FreelancerApplicationService bildet dabei die Transactionsgrenzen.
  * Jeder Aufruf erzeugt eine neue Transaktion

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  * Jeder Bounded Context sollte eine "Deployment Unit" bilden, z.B. ein Java WAR file oder ein EJB JAR
  * Die Bounded Contexts sind unabhängig designt, sie sollten daher auch unabhängig implementiert werden

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer1.png)

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer2.png)

%section{"data-markdown" => ""}
  \#### DDD - Vorteile

  * Der Domain Layer basiert nicht auf anderen Teilen der Architektur
  * Die Repository Implementierung kann getauscht werden, ohne die Businesslogik zu beeinflussen

%section{"data-markdown" => ""}
  \#### DDD -  Domain Layer

  * Enthält die Businesslogik, keine Abhängigkeiten der Infrastruktur
  * Die Modelle sollten nach dem CQS(Command-Query-Separation) Prinzip entworfen werden
  * --> Query Methoden geben lediglich Daten zurück ohne Zustände zu ändern
  * --> Command Methoden ändern den State

%section{"data-markdown" => ""}
  \#### DDD - Application Layer

  * Der Application Layer nimmt Kommandos des User Interface Layer an
  * Der Application Layer ruft UseCase Implementierungen im Domain layer auf
  * Der Application Layer biete Transactioskontrolle für Business Operationen

%section{"data-markdown" => ""}
  \#### DDD - Infrastructure Layer

  Der Infrastructure Layer bietet Infrastrukturabhängige Teile für alle anderen Layer


%section{"data-markdown" => ""}
  \#### DDD - User Interface Layer

  * Der User Interface Layer konsumiert Application Services und ruft Funktionalität der Businesslogik auf diesen Services auf.
  * Jeder Aufruf ist eine neue Transaktion
  * Der User Interface Layer kann beliebig implementiert sein, z.B. ein SOAP webservice, eine REST Resource oder eine Swing/AWT GUI

%section{"data-markdown" => ""}
  \#### DDD - Zusammenfassung

  \### Domain-driven Design is object oriented programming done right. *(Eric Evans)*

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \### Rückblick auf Architekturmuster

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section
  %h3 Chaos zu Struktur / Mud-to-structure
  %ul
    %li Organisation der Komponenten und Objekte eines Softwaresystems
    %li Die Funktionalität des Gesamtsystems wird in kooperierende Subsysteme aufgeteilt
    %li Zu Beginn des Softwareentwurfs werden Anforderungen analysiert und spezifiziert
    %li Integrierbarkeit, Wartbarkeit, Änderbarkeit, Portierbarkeit und Skalierbarkeit sollen berücksichtigt werden

%section{"data-markdown" => ""}
  \### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h3 Verteilte Systeme
  %ul
    %li Verteilung von Ressourcen und Dienste in Netzwerken
    %li Kein "zentrales System" mehr
    %li Basiert auf guter Infrastruktur lokaler Datennetze

%section{"data-markdown" => ""}
  \### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section
  %h3 Interaktive Systeme
  %ul
    %li Strukturierung von Mensch-Computer-Interaktionen
    %li Möglichst gute Schnittstellen für die Benutzer schaffen
    %li Der eigentliche Systemkern bleibt von der Benutzerschnittstelle unangetastet.

%section{"data-markdown" => ""}
  \### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section
  %h3 Adaptive Systeme
  %ul
    %li Unterstützung der Erweiterungs- und Anpassungsfähigkeit von Softwaresystemen.
    %li Das System sollte von vornherein mögliche Erweiterungen unterstützen
    %li Die Kernfunktionalität sollte davon unberührt bleiben kann.

%section{"data-markdown" => ""}
  \### Adaptive Systeme
  \#### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### Nutzen von Templates

  Beispiele:
  * arc42
  * Normen
  * Software Guidebook

%section{"data-markdown" => ""}
  \### ARC42
  \#### (Dr. Gernot Starke / Dr. Peter Hruschka)
  http://www.arc42.de/

  \#### *arc42 unterstützt Software- und Systemarchitekten. Es kommt aus der Praxis und basiert auf Erfahrungen internationaler Architekturprojekte und Rückmeldungen vieler Anwender.*

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### ARC42

  1. Einführung und Ziele
  2. Randbedingungen
  3. Kontextabgrenzung
  4. Lösungsstrategie
  5. Bausteinsicht
  6. Laufzeitsicht
  7. Verteilungssicht
  8. Querschnittliche Konzepte/Muster
  9. Entwurfsentscheidungen
  10. Qualitätsszenarien
  11. Risiken
  12. Glossar

%section{"data-markdown" => ""}
  \#### ARC42
  ![](/images/arc42.png)

%section{"data-markdown" => ""}
  \### IEEE Standards

  **IEEE Standards** documents are developed within the IEEE Societies and the Standards Coordinating Committees of
  the IEEE Standards Association (IEEE-SA) Standards Board. The IEEE develops its standards through a consensus
  development process, approved by the American National Standards Institute, which brings together volunteers representing
  varied viewpoints and interests to achieve the final product. Volunteers are not necessarily members of the
  Institute and serve without compensation. While the IEEE administers the process and establishes rules to promote
  fairness in the consensus development process, the IEEE does not independently evaluate, test, or verify the accuracy
  of any of the information contained in its standards or implementations thereof.

%section{"data-markdown" => ""}
  \### IEEE Standards

  * IEEE 802:    LAN
  * IEEE 802.3:  Carrier sense multiple access with collision detection (CSMA/CD)
  * IEEE 802.11: Wireless LAN
  * IEEE 830:    Recommended Practice for Software Requirements Specifications
  * IEEE 1394:   FireWire/i.Link Bussysteme
  * IEEE 1471:   Recommended Practice for Architectural Description of Software-Intensive Systems
  * IEEE 9945:   Portable Operating System Interface (POSIX®)

%section{"data-markdown" => ""}
  \### Software Guidebook

  * Template von Simon Brown aus dem Buch *"Software Architecture for Developers"*
  * Buch: https://leanpub.com/software-architecture-for-developers
  * Beispiel: https://leanpub.com/techtribesje (kostenlos)

%section{"data-markdown" => ""}
  \### Software Guidebook

  \#### Welche Informationen wünsche ich mir, wenn ich in ein neues Projekt komme?

  * Karten
  * Sichten
  * Geschichte
  * Praktische Informationen!

%section{"data-markdown" => ""}
  \### Software Guidebook
  \## Product vs project documentation

%section{"data-markdown" => ""}
  \### Software Guidebook
  1.  Context
  2. Functional Overview
  3. Quality Attributes
  4. Constraints
  5. Principles
  6. Software Architecture
  7. External Interfaces
  8. Code
  9. Data
  10. Infrastructure Architecture
  11. Deployment
  12. Operation and Support
  13. Development Environment

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben

  * Was waren die Gründe für Softwarearchitektur?
  * Was sollte eine Kontext-Sicht enthalten?
  * In welcher Beziehung stehen Architektur und Design?
  * Was besagt 'Conways Law'?
  * Nennen und erläutern Sie drei Arten von Architekturmustern
  * Für welche Systeme wird das MVC Muster typischerweise verwendet?

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Software Guidebook: Ein Beispiel

  * Beispiel: https://leanpub.com/techtribesje
  * Website: https://techtribes.je

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \### Technologien und Frameworks

%section{"data-markdown" => ""}
  \## Frameworks
  Ein Framework (englisch für Rahmenstruktur) ist ein Programmiergerüst, das in der Softwaretechnik, insbesondere im Rahmen der objektorientierten Softwareentwicklung sowie bei komponentenbasierten Entwicklungsansätzen, verwendet wird. Im allgemeineren Sinne bezeichnet man mit Framework auch einen Ordnungsrahmen.
  Ein Framework ist selbst noch kein fertiges Programm, sondern stellt den Rahmen zur Verfügung, innerhalb dessen der Programmierer eine Anwendung erstellt, wobei u. a. durch die in dem Framework verwendeten Entwurfsmuster auch die Struktur der individuellen Anwendung beeinflusst wird. Beispielsweise unterstützen die Microsoft Foundation Classes das Model-View-Controller-Muster.

  So beschrieben Ralph E. Johnson und Brian Foote bereits im Jahr 1988 im Artikel “Designing Reusable Classes” ("Journal of Object-Oriented Programming") ein Framework wie folgt:

  Ein Framework ist eine semi-vollständige Applikation. Es stellt für Applikationen eine wiederverwendbare, gemeinsame Struktur zur Verfügung. Die Entwickler bauen das Framework in ihre eigene Applikation ein, und erweitern es derart, dass es ihren spezifischen Anforderungen entspricht. Frameworks unterscheiden sich von Toolkits dahingehend, dass sie eine kohärente Struktur zur Verfügung stellen, anstatt einer einfachen Menge von Hilfsklassen.[1]
  Ein Framework gibt somit in der Regel die Anwendungsarchitektur vor. Dabei findet eine Umkehrung der Steuerung (Inversion of Control) statt: Der Programmierer registriert konkrete Implementierungen, die dann durch das Framework gesteuert und benutzt werden, statt – wie bei einer Klassenbibliothek – lediglich Klassen und Funktionen zu benutzen. Wird das Registrieren der konkreten Klassen nicht fest im Programmcode verankert, sondern „von außen“ konfiguriert, so spricht man auch von Dependency Injection.

  Ein Framework definiert insbesondere den Kontrollfluss der Anwendung und die Schnittstellen für die konkreten Klassen, die vom Programmierer erstellt und registriert werden müssen. Frameworks werden also im Allgemeinen mit dem Ziel einer Wiederverwendung „architektonischer Muster“ entwickelt und genutzt. Da solche Muster nicht ohne die Berücksichtigung einer konkreten Anwendungsdomäne entworfen werden können, sind Frameworks meist domänenspezifisch oder doch auf einen bestimmten Anwendungstyp beschränkt. Beispiele sind Frameworks für grafische Editoren, Buchhaltungssysteme oder Shops im World Wide Web.

  Eine allgemeingültige Definition von Frameworks gibt es aufgrund der hohen Anzahl von Diversitäten nicht. Oftmals wird der Begriff deswegen falsch angewendet, so dass beispielsweise bereits gewöhnliche Klassensammlungen fälschlicherweise als Framework deklariert werden. Dies rührt auch daher, dass der Begriff mittlerweile einen relativ hohen Stellenwert in der Informationstechnik einnimmt und durch eine fehlende absolute Definition missbräuchlich verwendet werden kann.
  Ein Framework ist selbst noch kein fertiges Programm, sondern stellt den Rahmen zur Verfügung, innerhalb dessen der Programmierer eine Anwendung erstellt, wobei u. a. durch die in dem Framework verwendeten Entwurfsmuster auch die Struktur der individuellen Anwendung beeinflusst wird. Beispielsweise unterstützen die Microsoft Foundation Classes das Model-View-Controller-Muster.

  So beschrieben Ralph E. Johnson und Brian Foote bereits im Jahr 1988 im Artikel “Designing Reusable Classes” ("Journal of Object-Oriented Programming") ein Framework wie folgt:

  Ein Framework ist eine semi-vollständige Applikation. Es stellt für Applikationen eine wiederverwendbare, gemeinsame Struktur zur Verfügung. Die Entwickler bauen das Framework in ihre eigene Applikation ein, und erweitern es derart, dass es ihren spezifischen Anforderungen entspricht. Frameworks unterscheiden sich von Toolkits dahingehend, dass sie eine kohärente Struktur zur Verfügung stellen, anstatt einer einfachen Menge von Hilfsklassen.[1]
  Ein Framework gibt somit in der Regel die Anwendungsarchitektur vor. Dabei findet eine Umkehrung der Steuerung (Inversion of Control) statt: Der Programmierer registriert konkrete Implementierungen, die dann durch das Framework gesteuert und benutzt werden, statt – wie bei einer Klassenbibliothek – lediglich Klassen und Funktionen zu benutzen. Wird das Registrieren der konkreten Klassen nicht fest im Programmcode verankert, sondern „von außen“ konfiguriert, so spricht man auch von Dependency Injection.

  Ein Framework definiert insbesondere den Kontrollfluss der Anwendung und die Schnittstellen für die konkreten Klassen, die vom Programmierer erstellt und registriert werden müssen. Frameworks werden also im Allgemeinen mit dem Ziel einer Wiederverwendung „architektonischer Muster“ entwickelt und genutzt. Da solche Muster nicht ohne die Berücksichtigung einer konkreten Anwendungsdomäne entworfen werden können, sind Frameworks meist domänenspezifisch oder doch auf einen bestimmten Anwendungstyp beschränkt. Beispiele sind Frameworks für grafische Editoren, Buchhaltungssysteme oder Shops im World Wide Web.

  Eine allgemeingültige Definition von Frameworks gibt es aufgrund der hohen Anzahl von Diversitäten nicht. Oftmals wird der Begriff deswegen falsch angewendet, so dass beispielsweise bereits gewöhnliche Klassensammlungen fälschlicherweise als Framework deklariert werden. Dies rührt auch daher, dass der Begriff mittlerweile einen relativ hohen Stellenwert in der Informationstechnik einnimmt und durch eine fehlende absolute Definition missbräuchlich verwendet werden kann.

  Ein Framework ist selbst noch kein fertiges Programm, sondern stellt den Rahmen zur Verfügung, innerhalb dessen der Programmierer eine Anwendung erstellt, wobei u. a. durch die in dem Framework verwendeten Entwurfsmuster auch die Struktur der individuellen Anwendung beeinflusst wird. Beispielsweise unterstützen die Microsoft Foundation Classes das Model-View-Controller-Muster.

  So beschrieben Ralph E. Johnson und Brian Foote bereits im Jahr 1988 im Artikel “Designing Reusable Classes” ("Journal of Object-Oriented Programming") ein Framework wie folgt:

  Ein Framework ist eine semi-vollständige Applikation. Es stellt für Applikationen eine wiederverwendbare, gemeinsame Struktur zur Verfügung. Die Entwickler bauen das Framework in ihre eigene Applikation ein, und erweitern es derart, dass es ihren spezifischen Anforderungen entspricht. Frameworks unterscheiden sich von Toolkits dahingehend, dass sie eine kohärente Struktur zur Verfügung stellen, anstatt einer einfachen Menge von Hilfsklassen.[1]
  Ein Framework gibt somit in der Regel die Anwendungsarchitektur vor. Dabei findet eine Umkehrung der Steuerung (Inversion of Control) statt: Der Programmierer registriert konkrete Implementierungen, die dann durch das Framework gesteuert und benutzt werden, statt – wie bei einer Klassenbibliothek – lediglich Klassen und Funktionen zu benutzen. Wird das Registrieren der konkreten Klassen nicht fest im Programmcode verankert, sondern „von außen“ konfiguriert, so spricht man auch von Dependency Injection.

  Ein Framework definiert insbesondere den Kontrollfluss der Anwendung und die Schnittstellen für die konkreten Klassen, die vom Programmierer erstellt und registriert werden müssen. Frameworks werden also im Allgemeinen mit dem Ziel einer Wiederverwendung „architektonischer Muster“ entwickelt und genutzt. Da solche Muster nicht ohne die Berücksichtigung einer konkreten Anwendungsdomäne entworfen werden können, sind Frameworks meist domänenspezifisch oder doch auf einen bestimmten Anwendungstyp beschränkt. Beispiele sind Frameworks für grafische Editoren, Buchhaltungssysteme oder Shops im World Wide Web.

  Eine allgemeingültige Definition von Frameworks gibt es aufgrund der hohen Anzahl von Diversitäten nicht. Oftmals wird der Begriff deswegen falsch angewendet, so dass beispielsweise bereits gewöhnliche Klassensammlungen fälschlicherweise als Framework deklariert werden. Dies rührt auch daher, dass der Begriff mittlerweile einen relativ hohen Stellenwert in der Informationstechnik einnimmt und durch eine fehlende absolute Definition missbräuchlich verwendet werden kann.



  Vorteile von Frameworks

  Aus der Erklärung von Frameworks ergeben sich auch schon die Vorteile von Frameworks für das Programmieren von Code.
  Wiederkehrende Aufgaben sind im Framework schon "vorprogrammiert" und können beliebig oft wiederverwendet werden.
  Ein Framework bietet außerdem genormte Schnittstellen zu bestimmten Quellen, etwa zu Datenbanken. Dadurch lässt sich eine Quelle einfacher ansprechen.

  Frameworks erleichtern die Programmierarbeit und sparen dem Entwickler viel Zeit.
  Wie wähle ich ein Framework aus?


%section{"data-markdown" => ""}
  1.	Popularity and community size
  The more well-known and recognized the framework is, the more it will be “living,” evolving and complete: new ideas, the number and quality of plug-ins, etc.

%section{"data-markdown" => ""}
  2.	Philosophy
  This is the very essence of the framework: it is a fundamental criterion for ensuring that it will meet your needs. A tool developed by professionals for their own needs will obviously meet the demands of other professionals.

%section{"data-markdown" => ""}
  3.	Sustainability
  Before choosing a framework, make sure that it will be able to keep up with you for the duration. This simplifies both the maintenance and upgrading of your applications.

%section{"data-markdown" => ""}
  4.	Support
  Another criterion that should not be overlooked is the ease of finding answers to your questions and getting help. Identify the support that is available: from the publisher. From a community (mailing lists, IRC, etc.)? From Service Companies (development, support, training)?

%section{"data-markdown" => ""}
  5.	Technique
  To avoid becoming trapped in a labyrinth, it is always preferable to choose an interoperable solution; one that respects best practices in terms of development (design patterns).

%section{"data-markdown" => ""}
  6.	Security
  Any application is potentially vulnerable. To minimize risk, it is always better to select a framework capable of ensuring security functions (XSS management, for example).

%section{"data-markdown" => ""}
  7.	Documentation
  It is an absolute necessity to evaluating the nature, volume and quality of existing literature about a framework: a well-documented tool is both easier to use and more upgradeable.

%section{"data-markdown" => ""}
  8.	License
  Licenses are important simply because they can have a significant impact on your applications. For example, an application developed using a GPL-licensed framework will necessarily be subject to GPL. On the other hand, this is not the case for an MIT-licensed framework.

%section{"data-markdown" => ""}
  9.	Availability of resources on the market
  Perhaps you would want to have a technical team surround you during the development phase or in the longer term, for both maintenance and upgrades. In other words, make sure that the skills required for the tool that you are using are available on the open market.

%section{"data-markdown" => ""}
  10. Try it out!
  That's the key! Don't be satisfied with reading reviews, comments and rumors, good or bad, on the Internet. By testing it out, you will be able to make up your own mind and ensure that you are completely comfortable with the tool.

%section{"data-markdown" => ""}
  1. Usage Context
  Before you even start looking at a frameworks, you'll need to make a list of your requirements and whether a framework is suitable for that purpose.

  You are in need of a framework if:

  your application is primarily based on CRUD operations
  you need proper separation of the UI and underlying logic but don't have the time to implement a proper system
  you find yourself having a self made library you use in each of your applications covering user authentication, sessions and other usual operations associated with creating a web application
  you have a boss who wants you to create a CMS for them in 2 days and you already know the framework
  You DON'T need a framework if:

  you want a pretty URL system alone
  you want only a specific part of the framework like its ORM
  you are on a tight timeline and you need to learn the framework from scratch
  you were told frameworks cure cancer

%section{"data-markdown" => ""}
  2. License
  Before you start developing with a framework, see what kind of license the framework is distributed under. While most licenses are pretty liberal to work with and lets you create commercial applications, some of them are not so generous. The last thing you'd want is to create an entire application only to find out that the license doesn't allow you to distribute it commercially. Better do your research before than suffering after.

  Do note that this isn't limited to the framework alone. The plugin or extension you made use of for the extra functionality may have a hidden clause. Check it's license too!

%section{"data-markdown" => ""}
  3. Software Pattern
  Almost every framework out there exclusively uses the MVC pattern. MVC, which stands for Model-View-Controller, helps you keep your data: the model, the logic: the controller and the user interface: the view, separate from each other. This in turn lets you write better, tighter code which ultimately results in better applications.

  Just because almost everyone uses MVC doesn't mean that is everything you need to know though. There are a couple of variants including MVP: Model-View-Presenter, MVA: Model-View-Adapter and AVC: Application-View-Controller.

%section{"data-markdown" => ""}
  4. Hosting Requirements
  As web developers, we may be inclined to building applications on cutting edge platforms but often the need and budget of the client comes first. Often it may be out of the budget to get a dedicated host to place our applications on and we'll have to settle with shared hosting with normal modules and settings.

  Frameworks which play nice with shared hosting include:

  CodeIgniter
  CakePHP
  Kohana
  Zend Framework
  Most other PHP frameworks
  Frameworks which require relatively non-traditional setups:

  Ruby on Rails
  Django
  Pylons
  Most non-PHP frameworks
  In all honesty though, you can still run frameworks like Django off an off the shelf shared host. It'll just require that the server has the necessary module installed. You may be able to run it off CGI but it'll be a lot slower than running it natively.

%section{"data-markdown" => ""}
  5. Ease of Installation
  Tutorial Image
  Ease of installation plays a very important role whilst choosing a framework. A framework, however feature laden or quick it may be, can pose quite a problem if one has to run through a number of steps just to get it installed and working.

  This will also pose a big problem once the application is ready, tested and needs to be deployed to the production server. A framework with ease of installation and just as easy deployment gets brownie points here.

  For a lot of the frameworks, set up is as simple as setting the right values in the configuration file whilst for others it may be a very time consuming, elaborate affair. Choose a framework which lets you get up and running as rapidly as possible.

%section{"data-markdown" => ""}
  6. Learning Curve
  Tutorial Image
  Every framework has its own tiny universe: naming conventions, directory structure and what nots. Some frameworks are rather flexible when it comes to these while others are very, very strict throwing up errors at the tiniest of mistakes. Some frameworks follow general conventions while implementing a feature while others may strike out and do its own thing. While choosing a framework, remember to choose one that has the smallest possible learning curve.

  If you don't know the language the framework is written in, make a note of including the language itself to the learning curve. I've seen a number of developers jumping to Django from CakePHP and struggling since they need to learn both Python and Django at the same time. If you need to learn both the framework and the language it was written in, pace yourself!

%section{"data-markdown" => ""}
  7. Core Library
  Tutorial Image
  Let's face it; it is for the core library that most people adopt a framework. The library must be in such as that it frees you from writing repetitive code but still provides a way for you to tinker with it if you need more control or features.

  Most frameworks offer libraries which cover almost all of the following list:

  AJAX
  Authentication
  Authorization
  Caching
  Data Sanitization
  Data Validation
  Templating
  URL mapping or rewriting
  Of course, not every one needs a framework brimming with features. A lot of people prefer frameworks to handle the bare minimum whilst letting the developer handle the rest. In these cases, you'll need to make sure the framework in question has only the features you need.

  A current trend among frameworks is that they are created as a library of libraries. In other words, it lets you swap out parts of the library with another part of your choice. An excellent example of this would be Pylons. It lets you switch out almost all of its parts starting from the ORM right down to its templating language. People like these loosely coupled frameworks just as much as the frameworks which are tightly couple with respect to its core components.

%section{"data-markdown" => ""}
  8. DB Abstraction and ORM
  Tutorial Image
  Almost every application has to access a database to either read data off or edit its contents. Either way, you'll be doing this along the length of the application and with this in mind, most frameworks lets you use an database access class you can make a use of. So while choosing an application, choose one which lets your application become database agnostic. You'll never have to care about the database part incase you need to switch out databases if your framework takes care of that.

  The second part you'll need to think about is the framework's ORM capabilities. Without getting technical, ORM or Object Relational Mapping lets you express data as an object and see how it relates to other objects. Imagine an object database you can pull information from, if you will.

  Frameworks which have ORM capabilities include CakePHP, Django and Ruby. With frameworks like Pylons, you can use your ORM of choice.

%section{"data-markdown" => ""}
  9. Included JS Library
  Tutorial Image
  Another point of contention is the bundled JavaScript library. While most libraries let you swap out the library with ease, the AJAX methods inside the framework are mostly still aimed towards a specific JS library. This implicitly means that you'll have to manually write the functionality yourself. On the other hand are frameworks with library agnostic methods which let you swap out the JavaScript library with little to no hassle.

  Just as a reference, both CakePHP and Ruby on Rails ship with Prototype and Scriptaculous as standard.

%section{"data-markdown" => ""}
  10. Unit Testing
  Tutorial Image
  I am one of those developers who swear by unit testing. Wikipedia defines unit testing as:

  Unit testing is a software verification and validation method in which a programmer tests if individual units of source code are fit for use. A unit is the smallest testable part of an application.

  Frameworks which lets me write unit tests are a definite plus in this case. A lot of frameworks including Code Igniter, CakePHP and Zend lets you create custom tests in addition to the core tests to check the critical parts of your application.

%section{"data-markdown" => ""}
  11. Scaling
  Tutorial Image
  The average web developer doesn't have to worry about the scalability of a framework. As often is the case, I/O and network latency are often the issue rather than a framework's scalability. Even Twitter's mythical scalability problem wasn't the fault of the framework in question.

  If someone asks you to layoff a framework pointing out scaling problems, disregard them. The framework is rarely the reason of the scaling issue. Sure, you could optimize the code a little bit but often the brunt of the scaling issue lies elsewhere.

%section{"data-markdown" => ""}
  12. Documentation
  Tutorial Image
  A framework's documentation is often key to its success. Well explained, detailed documentation draws in the power users and evangelists who then bring in more people. With shoddy, confusing documentation people are going to just walk off confused and annoyed.

  Look for a framework which has thorough documentation with plenty of examples, snippets, sample code, articles and tutorials. Screencasts like Jeffrey's are a special plus since it'll let you zip right along.

%section{"data-markdown" => ""}
  13. The Community
  Tutorial Image
  Inevitably, even with proper documentation, you are going to run into errors to rectify which, you are going to have to ask the community behind the framework for help. I've personally interacted with communities which vitriolically attacked programmers new to the framework and sneered at them while on the other extreme I've seen communities cheerfully welcomes newbies and teach them the tricks of the trade. I think there is no need to say which framework I ended up choosing and started working permanently on.

  As often is the case, the communities behind a framework make or break the framework. Too snobby and you'll resent the framework instead of the people. Well mannered and you'll gravitate towards the framework. Choose a framework which has a friendly community which helps developers new to the platform.

%section{"data-markdown" => ""}
  14. Bug Fixes/ Updates
  Tutorial Image
  One of the reasons web developers shy away from just creating their own frameworks is the fact that they alone are in charge of fixing the bugs and updates. With a big framework, you literally have thousands of programmers sifting through the code and putting it through its paces on a daily basis. Bugs, if and when they are found, are squashed as soon as possible after they are found.

  Choose a framework which isn't stagnant. You don't want a hacker to tell you that a security vulnerability exists in the framework through a page he hacked on your site. You'd rather hear that from the framework developers, hopefully with a link to a patch to the issue. Choose a framework which is updated often, is open about the bugs it finds and more importantly fixes the bugs people come across as soon as possible.

%section{"data-markdown" => ""}
  15. Ease of Creating an Extension and Availability
  Tutorial Image
  While a framework covers all of the important bases of an application, chances are, you'll still have to write a bunch of code. Make it generic enough and you can re-purpose it into a component suitable for reuse in your other applications or even better release it to the general public so they make use of it in their applications..

  Choose a framework which lets you extend the framework easily and with minimal fuss. With CakePHP for example, extending a controller is taken care of by components and views by helpers. In either case, creating an extension is as simple as defining a new class which inherits from a parent base class.

  While choosing a framework, also keep in mind the availability of plugins. Often you won't have the time to create a custom extension from scratch. Having a huge pool of extensions to choose from greatly alleviates this issue. Choose not by the number of extensions but by the quality of the extensions.


%section{"data-markdown" => ""}
  https://en.wikipedia.org/wiki/Comparison_of_web_frameworks



%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben

  * Was waren die Gründe für Softwarearchitektur?
  * Was sollte eine Kontext-Sicht enthalten?
  * In welcher Beziehung stehen Architektur und Design?
  * Was besagt 'Conways Law'?
  * Nennen und erläutern Sie drei Arten von Architekturmustern
  * Für welche Systeme wird das MVC Muster typischerweise verwendet?

%section{"data-markdown" => ""}
  \## Fragen?

  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
