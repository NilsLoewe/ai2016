---
title: Vorlesung 12 - Klausurvorbereitung
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule fÃ¼r angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils LÃ¶we / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \### Ziele dieser Vorlesung

  * Was ist Softwarearchitektur und wozu braucht man sie?
  * Was muss ein Softwarearchitekt / eine Softwarearchitektin kÃ¶nnen?
  * Wie konzipiert man eine groÃŸe Anwendung?
  * Wie werden Architekturen entworfen, dokumentiert und bewertet?

%section{"data-markdown" => ""}
  \### **Was ist Softwarearchitektur?**
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Definitionen fÃ¼r Softwarearchitektur

%section{"data-markdown" => ""}
  %p
    Die Architektur eines Softwaresystems ist die Menge der Haupt-Designentscheidungen Ã¼ber das System. *(Taylor)*
  *(â€œA software systemâ€™s architecture is the set of principal design decisions about the system.â€)*

%section{"data-markdown" => ""}
  Die Software-Architektur ist die grundlegende Organisation eines Systems, dargestellt durch dessen Komponenten, deren Beziehungen zueinander und zur Umgebung sowie die Prinzipien, die den Entwurf und die Evolution des Systems bestimmen. *(Reussner)*

%section{"data-markdown" => ""}
  Software Architecture = { what, how, why } *(Perry and Wolf)*

%section{"data-markdown" => ""}
  The software architecture of deployed software is determined by those aspects that are the hardest to change. *(Chris Verhoef)*

%section{"data-markdown" => ""}
  \### Architektur besteht aus Strukturen
  * die Komponenten (Bausteine), aus denen ein System besteht
  * die wesentlichen (extern sichtbaren) Eigenschaften dieser Komponenten
  * die Beziehungen der Komponenten untereinander

%section{"data-markdown" => ""}
  \### Architektur beschreibt eine LÃ¶sung im Sinne eines Bauplans
  (die Architektur eines GebÃ¤udes besteht aus einer Sammlung von PlÃ¤nen - nicht aus Steinen und Zement)
  \#### Erst die *Implementierung* macht aus den Komponenten und Schnittstellen der Architektur ein reales System.

%section{"data-markdown" => ""}
  \### Architektur basiert auf Entwurfsentscheidungen
  * Entscheidungen zum Entwurf der Komponenten
  * Entscheidung fÃ¼r eine bestimmte Technologie

  \#### Die Konsequenz vieler Entscheidungen kÃ¶nnen Architekten erst sehr viel spÃ¤ter beurteilen!

%section{"data-markdown" => ""}
  \### Architektur schafft VerstÃ¤ndlichkeit
  * komplexe Anforderungen &rarr; geordnete Strukturen
  * angemessene und problembezogene Dokumentation
  %br
  *Management:* Anforderungen erfÃ¼llbar / erfÃ¼llt?
  %br
  *neue Mitarbeiter:* Systemstruktur kennen lernen
  %br
  *Wartungsteams:* betroffene Bestandteile leichter finden und Folgen von Ã„nderungen abschÃ¤tzen
  %br
  *Systembetreiber:* Welche Software-Komponenten laufen auf welchen physischen Systemen ab?

%section{"data-markdown" => ""}
  \### Architektur ist der Rahmen fÃ¼r flexible Systeme
  * stellt FlexibilitÃ¤t und Erweiterbarkeit sicher &rarr; *"framework for change"* (Tom DeMarco)

%section{"data-markdown" => ""}
  \### Architektur ist Abstraktion
  * Essenzielle Aufgabe von Architekten: Weglassen von nicht benÃ¶tigten Informationen
  * Informationen werden bewusst gefiltert um die Darstellung lesbar und verstÃ¤ndlich zu halten

%section{"data-markdown" => ""}
  \### Architektur schafft QualitÃ¤t
  %br
  Die QualitÃ¤t eines Systems bezeichnet die Summe seiner nicht-funktionale Eigenschaften:
  * Performance
  * VerstÃ¤ndlichkeit
  * FlexibilitÃ¤t
  * ...
  %br
  Das sind meistens die schwierigen Anforderungen!


%section{"data-markdown" => ""}
  \### Architektur vs. Entwurf/Design?
  * die Grenze ist flieÃŸend
  * Design (oder Entwurf) bezeichnet den Prozess der Erstellung der Architektur
  %br
  &rarr; Gehen Sie mit diesen Begriffen pragmatisch um und suchen Sie nicht nach einer "formalen" Definition.

%section{"data-markdown" => ""}
  \### Die Aufgaben von Softwarearchitekten
  %br

  "Das Leben von Software-Architekten besteht aus einer langen und schnellen Abfolge suboptimaler Entwurfsentscheidungen, die meist im Dunkel getroffen werden."
  %br
  (Phillipe Kruchten)

%section{"data-markdown" => ""}
  \### Architekturen entstehen in Zyklen und Iterationen
  %br
  ![](/images/moving_target.png)
  %br
  Bildquelle: Starke / "Effektive Softwarearchitekturen" (5. Auflage)

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Seit wann gibt es den Begriff der Softwarearchitektur?

  \### Konferenz Ã¼ber Softwaretechnik in Rom
  %br
  %i Software Engineering Techniques. Report of a Conference Sponsored by the NATO Science Committee. Scientific Affairs Division, NATO, 1970, S. 12.

%section{"data-markdown" => ""}
  \#### Warum?

  Die Systeme wurden in den 1960ern so komplex, dass sie von mehreren Teams entwickelt werden mussten.

%section
  %h4 Beispiel: IBM OS/360

  %h3 Planung
  %ul
    %li Entwicklungskosten: 40 Mio. USD
    %li Lines of Code: 1 Mio.
    %li Fertigstellung: 1965

%section

  %h4 Beispiel: IBM OS/360

  %h3 RealitÃ¤t
  %ul
    %li Entwicklungskosten: 500 Mio. USD (Faktor 12,5)
    %li Lines of Code: 10 Mio. (Faktor 10)
    %li Fertigstellung: 1967 (2 Jahre zu spÃ¤t)

%section{"data-markdown" => ""}
  \#### Softwarearchitektur im Lauf der Zeit

  \#### Erste Beschreibung von "Dekomposition, Zerlegung, Entwurf"

  * 1970er: Eher im Kontext von Hardware genutzt
  * 1972:  *"On the criteria to be used in decomposing systems into modules"* von D. L. Parnas
  * 1975: *"The Mythical Man Month"* von Frederick Brooks


%section{"data-markdown" => ""}
  \#### Softwarearchitektur im Lauf der Zeit
  \#### UnabhÃ¤ngiges Teilgebiet der Softwaretechnik
  \#### Konzept der Schnittstellen und Konnektoren

  * 1992: *"Foundations for the Study of Software Architecture"* von Dewayne Perry und Alexander Wolf
  * 1995: *"Software Architecture Analysis Method"* des Software Engineering Institute

%section{"data-markdown" => ""}
  \#### Softwarearchitektur im Lauf der Zeit
  \#### Allgemeine Verbreitung und "Stand der Technik"

  * 2000: *"IEEE 1471:2000 Norm Recommended Practice for Architectural Description of Software-Intensive Systems"*
  * 2003: Zertifizierung als Softwarearchitekt durch die iSAQB (International Software Architect Qualification Board)
  * 2003: UML 2.0 ist geeignet um Softwarearchitekturen zu beschreiben

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Warum Ã¼berhaupt Sichten?
  %br
  \#### *"Es ist eine offensichtliche Wahrheit, dass auch eine perfekte Architektur nutzlos bleibt, wenn sie nicht verstanden wird..."*
  %br
  Felix Bachmann und Len Bass in "Software Architecture Documentation in Practice"

%section{"data-markdown" => ""}
  \## 1.
  \#### Eine einzelne Darstellung kann die Vielschichtigkeit und KomplexitÃ¤t einer Architektur nicht ausdrÃ¼cken.
  %br
  \#### - Genauso wenig, wie man nur mit einem Grundriss ein Haus bauen kann.

%section{"data-markdown" => ""}
  \## 2.
  \#### Sichten ermÃ¶glichen die Konzentration auf einzelne Aspekte des Gesamtsystems und reduzieren somit die KomplexitÃ¤t der Darstellung.

%section{"data-markdown" => ""}
  \## 3.
  \#### Die Projektbeteiligten haben ganz unterschiedliche InformationsbedÃ¼rfnisse.

%section{"data-markdown" => ""}
  ![](/images/4-sichten.png)
  %br
  Bildquelle: "Effektive Softwarearchitekturen" von Gernot Starke

%section{"data-markdown" => ""}
  \#### Architekten mÃ¼ssen Projektbeteiligten die Architektur erklÃ¤ren bzw. sie verteidigen/vermarkten
  * die entworfenen Strukturen
  * die getroffenen Entscheidungen
  * ihre Konzepte + BegrÃ¼ndungen + Vor- und Nachteile
  %br
  &rarr; Mit Hilfe von unterschiedlichen Sichten lassen sich viele Aspekte von Architektur verstÃ¤ndlich darstellen.

%section{"data-markdown" => ""}
  \#### Ãœberblick Ã¼ber die vier Sichten
  ![](/images/vier_sichten_auf_architektur.png)
  %br
  Bildquelle: "Effektive Softwarearchitekturen" von Gernot Starke

%section{"data-markdown" => ""}
  \## Kontextsicht
  * Wie ist das System in seine Umgebung eingebettet?
  * zeigt das System als Blackbox in seinem Kontext aus der Vogelperspektive

%section{"data-markdown" => ""}
  \### Kontextsicht - Enthaltene Informationen:
  * Schnittstellen zu Nachbarsystemen
  * Interaktion mit wichtigen Stakeholdern
  * wesentliche Teile der umgebenden Infrastruktur

%section{"data-markdown" => ""}
  \#### Kontextsicht - Beispiel
  ![](/images/kontextsicht_beispiel.png)
  %br
  Bildquelle: "Effektive Softwarearchitekturen" von Gernot Starke

%section{"data-markdown" => ""}
  \## Bausteinsicht
  * Wie ist das System intern aufgebaut?
  * unterstÃ¼tzt Auftaggeber und Projektleiter bei der ProjektÃ¼berwachung
  * dienent der Zuteilung von Arbeitspaketen
  * dient als Referenz fÃ¼r Software-Entwickler

%section{"data-markdown" => ""}
  \### Bausteinsicht - Enthaltene Informationen:
  * statische Strukturen der Bausteine des Systems
  * Subsysteme
  * Komponenten und deren Schnittstellen

%section{"data-markdown" => ""}
  \#### Bausteinsicht - Beispiel
  ![](/images/bausteinsicht_beispiel.png)
  %br
  Bildquelle: "Effektive Softwarearchitekturen" von Gernot Starke

%section{"data-markdown" => ""}
  \## Laufzeitsicht
  * Wie lÃ¤uft das System ab?
  * Welche Bausteine des Systems existieren zur Laufzeit?
  * Wie wirken die Bausteine zusammen?

%section{"data-markdown" => ""}
  \#### Laufzeitsicht - Beispiel
  ![](/images/laufzeitsicht_beispiel.png)
  %br
  Bildquelle: "Effektive Softwarearchitekturen" von Gernot Starke

%section{"data-markdown" => ""}
  \##  Verteilungssicht / Infrastruktursicht
  * In welcher Umgebung lÃ¤uft das System ab?
  * zeigt das System aus Betreibersicht

%section{"data-markdown" => ""}
  \### Verteilungssicht - Enthaltene Informationen:
  * Hardwarekomponenten: Rechner, Prozessoren
  * Netztopologien
  * Netzprotokolle
  * sonstige Bestandteile der physischen Systemumgebung

%section{"data-markdown" => ""}
  \#### Verteilungssicht - Beispiel
  ![](/images/verteilungssicht_beispiel.png)
  %br
  Bildquelle: "Effektive Softwarearchitekturen" von Gernot Starke

%section{"data-markdown" => ""}
  \## Gibt es noch weitere Sichten?

%section{"data-markdown" => ""}
  \### Empfehlung
  * Verzichten Sie mÃ¶glichst auf weitere Sichten
  * Jede Sicht kostet Erstellungs- und Wartungsaufwand
  * Die grundlegenden Aspekte der Architektur- und Systementwicklung decken die vier Sichten ab

%section
  %h4 Beispiel (nach Peter Hruschka):
  %pre
    %code
      :preserve
        Beim HÃ¤userbau kÃ¶nnten Kakteen- und OrchideenzÃ¼chter nach der Sonnenein-
        strahlung in einzelnen RÃ¤umen fragen und zum Wohle ihrer pflanzlichen Lieblinge
        einen gesonderten Plan wÃ¼nschen. Wie groÃŸ ist Ihrer Erfahrung nach die Zahl derer,
        die beim Bau oder beim Kauf einer Immobilie diese â€žpflanzlicheâ€œ Sicht als Entschei-
        dungskriterium verwenden?

%section{"data-markdown" => ""}
  \### Wie viel Aufwand fÃ¼r welche Sicht?

  \##### Rechnen Sie damit, dass Sie 60 bis 80% der Zeit, die Sie fÃ¼r den Entwurf der Architektursichten insgesamt benÃ¶tigen, alleine fÃ¼r die Ausgestaltung der Bausteinsicht aufwenden. Der ausschlaggebende Grund hierfÃ¼r: Die Bausteinsicht wird oftmals wesentlich detaillierter ausgefÃ¼hrt als die Ã¼brigen Sichten.
  \##### Dennoch sind die Ã¼brigen Sichten fÃ¼r die Software-Architektur und das Gelingen des gesamten Projektes wichtig! Lassen Sie sich von diesem relativ hohen Aufwand fÃ¼r die Bausteinsicht in keinem Fall dazu verleiten, die anderen Sichten zu ignorieren.
  \##### *Quelle: Starke/Effektive Softwarearchitekturen*

%section{"data-markdown" => ""}
  \###  Wechselwirkungen dokumentieren

  \##### Sie sollten in Ihren Architekturbeschreibungen die Entwurfsentscheidungen dokumentieren, die besonderen Einfluss auf andere Sichten haben. Beispielsweise bestimmt die Entscheidung fÃ¼r eine zentrale Datenhaltung in der Bausteinsicht maÃŸgeblich den Aufbau der technischen Infrastruktur

%section{"data-markdown" => ""}
  \###  Wechselwirkungen dokumentieren
  * Bessere Nachvollziehbarkeit von Entscheidungen
  * Auswirkungen von Ã„nderungen werden vereinfacht
  * Das VerstÃ¤ndnis der Architekturbeschreibung wird einfacher, da die ZusammenhÃ¤nge zwischen den Sichten klarer werden


%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Was ist QualitÃ¤t?

%section{"data-markdown" => ""}
  \##### *Was ist QualitÃ¤t?*
  \#### Duden: QualitÃ¤t=â€žBeschaffenheit, GÃ¼te, Wertâ€œ

%section{"data-markdown" => ""}
  \##### *Was ist QualitÃ¤t?*
  \#### Die QualitÃ¤t stimmt, wenn der Kunde wiederkommt und nicht das Produkt

%section{"data-markdown" => ""}
  \##### *Was ist QualitÃ¤t?*
  ![](/images/triple_constraint.png)
  %br
  *Quelle: http://pm-blog.com/*

%section{"data-markdown" => ""}
  \### QualitÃ¤t ist ein wichtiges Ziel fÃ¼r Software-Architekten

%section{"data-markdown" => ""}
  \### Probleme von QualitÃ¤t
  * QualitÃ¤t ist nur indirekt messbar
  * QualitÃ¤t ist relativ (jeweils anders fÃ¼r: Anwender, Projektleiter, Betreiber, ...)
  * Die QualitÃ¤t der Architektur korreliert nicht notwendigerweise mit der CodequalitÃ¤t
  * ErfÃ¼llung aller funktionalen Anforderungen lÃ¤sst keinerlei Aussage Ã¼ber die Erreichung der QualitÃ¤tsanforderungen zu

%section{"data-markdown" => ""}
  \### Beispiel funktionale Anforderung â€žSortierung von Datenâ€œ

  * Kann funktional erfÃ¼llt sein, aber nichtfunktional?
  * Sortierung groÃŸer Datenmengen (Terabyte), die nicht mehr zeitgleich im Hauptspeicher gehalten werden kÃ¶nnen
  * Sortierung robust gegenÃ¼ber unterschiedlichen Sortierkriterien (Umlaute, akzentuierte Zeichen, Phoneme, Ã„hnlichkeitsmaÃŸe und anderes)
  * Sortierung fÃ¼r viele parallele Benutzer
  * Sortierung unterbrechbar fÃ¼r lang laufende SortiervorgÃ¤nge
  * Erweiterbarkeit um weitere Algorithmen, beispielsweise fÃ¼r ressourcenintensive Vergleichsoperationen
  * Entwickelbarkeit im rÃ¤umlich verteilten Team

%section{"data-markdown" => ""}
  \#### QualitÃ¤tsmerkmale nach DIN/ISO 9126

  \### FunktionalitÃ¤t
  \### ZuverlÃ¤ssigkeit
  \### Benutzbarkeit
  \### Effizienz
  \### Ã„nderbarkeit
  \### Ãœbertragbarkeit

%section{"data-markdown" => ""}
  \#### FunktionalitÃ¤t
  \### Existenz eines Satzes von Funktionen mit spezifizierten Eigenschaften

%section{"data-markdown" => ""}
  \#### ZuverlÃ¤ssigkeit
  \### FÃ¤higkeit, Leistungsniveau Ã¼ber einen Zeitraum aufrecht zu erhalten

%section{"data-markdown" => ""}
  \#### Benutzbarkeit
  \### Aufwand zur Benutzung und individuelle Beurteilung der Benutzung

%section{"data-markdown" => ""}
  \#### Effizienz
  \### VerhÃ¤ltnis Leistungsniveau / eingesetzte Betriebsmittel

%section{"data-markdown" => ""}
  \#### Ã„nderbarkeit
  \### Aufwand zur DurchfÃ¼hrung von Ã„nderungen

%section{"data-markdown" => ""}
  \#### Ãœbertragbarkeit
  \### Eignung zur Ãœbertragung in andere Umgebung

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Was sind Architekturmuster?

%section
  %h4
    A pattern for software architexture describes a particular
    recurring design problem that arises in specific design
    contexts, and presents a well-proven generic scheme for
    its solution. The solution scheme is specified by describing
    its constituent components, theis relationships, and the ways
    in which they collaborate.
  %p
    %i (1996 / Pattern Oriented Software Architectute)

%section
  %h4
    Ein Architekturmuster beschreibt eine bewÃ¤hrte LÃ¶sung fÃ¼r ein wiederholt auftretendes Entwurfsproblem
  %p
    %i (Effektive Softwarearchitekturen)

%section
  %h4
    Ein Architekturmuster definiert den Kontext fÃ¼r die Anwendbarkeit der LÃ¶sung
  %p
    %i (Effektive Softwarearchitekturen)

%section{"data-markdown" => ""}
  \### Warum Architekturmuster?

%section{"data-markdown" => ""}
  \#### Erfolg kommt von Weisheit.
  \#### Weisheit kommt von Erfahrung.
  \#### Erfahrung kommt von Fehlern.

%section{"data-markdown" => ""}
  \#### Haben Sie jemals einen dummen Fehler zweimal begangen?
  \#### *â€“ Willkommen in der realen Welt.*
  \#### Haben Sie diesen Fehler hundertmal hintereinander gemacht?
  \#### *-Willkommen in der Software-Entwicklung.*

%section{"data-markdown" => ""}
  \#### Aus Fehlern kann man hervorragend lernen.
  Leider akzeptiert kaum ein Kunde Fehler, nur weil Sie Ihre Erfahrung als Software-Architekt sammeln.

%section{"data-markdown" => ""}
  \#### In dieser Situation helfen Heuristiken.
  Heuristiken kodifizieren Erfahrungen anderer Architekten und Projekte, auch aus anderen Bereichen der Systemarchitektur.

%section{"data-markdown" => ""}
  \#### Heuristiken sind nicht-analytische Abstraktionen von Erfahrung
  Es sind Regeln zur Behandlung komplexer Probleme,
  fÃ¼r die es meist beliebig viele LÃ¶sungsalternativen gibt.
  Heuristiken kÃ¶nnen helfen, KomplexitÃ¤t zu reduzieren.

%section{"data-markdown" => ""}
  \#### Andere Begriffe fÃ¼r Heuristiken sind auch â€žRegelnâ€œ, â€žMusterâ€œ oder â€žPrinzipienâ€œ.
  Es geht immer um Verallgemeinerungen und Abstraktionen von konkreten Situationen.

%section{"data-markdown" => ""}
  \#### Heuristiken bieten Orientierung im Sinne von Wegweisern, StraÃŸenmarkierungen und Warnschildern.
  Sie geben allerdings lediglich Hinweise und garantieren nichts. Es bleibt in Ihrer Verantwortung, die passen-
  den Heuristiken fÃ¼r eine bestimmte Situation auszuwÃ¤hlen:

%section{"data-markdown" => ""}
  \#### Die Kunst der Architektur liegt nicht in der Weisheit der Heuristiken, sondern in der Weisheit, a priori die passenden Heuristiken fÃ¼r das aktuelle Projekt auszuwÃ¤hlen.

%section{"data-markdown" => ""}
  \### Architektur: Von der Idee zur Struktur
  Ein klassischer und systematischer Ansatz der Beherrschung von KomplexitÃ¤t lautet â€žteile
  und herrscheâ€œ (divide et impera). Das Problem wird in immer kleinere Teile zerlegt, bis diese
  Teilprobleme eine Ã¼berschaubare GrÃ¶ÃŸe annehmen.

%section{"data-markdown" => ""}
  \### Anwendung auf Software-Architekturen:

  *klassische Architekturmuster*
  \#### Horizontale Zerlegung: â€žIn Scheiben schneidenâ€œ
  \#### Vertikale Zerlegung: â€žIn StÃ¼cke schneidenâ€œ
  *weitere Architekturmuster*
  \#### Alles ist mÃ¶glich...

%section{"data-markdown" => ""}
  \#### Ãœberblick Ã¼ber Architekturmuster
  \### *Arten von Architekturmustern?*

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section
  %h3 Chaos zu Struktur / Mud-to-structure
  %ul
    %li Organisation der Komponenten und Objekte eines Softwaresystems
    %li Die FunktionalitÃ¤t des Gesamtsystems wird in kooperierende Subsysteme aufgeteilt
    %li Zu Beginn des Softwareentwurfs werden Anforderungen analysiert und spezifiziert
    %li Integrierbarkeit, Wartbarkeit, Ã„nderbarkeit, Portierbarkeit und Skalierbarkeit sollen berÃ¼cksichtigt werden

%section{"data-markdown" => ""}
  \### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h3 Verteilte Systeme
  %ul
    %li Verteilung von Ressourcen und Dienste in Netzwerken
    %li Kein "zentrales System" mehr
    %li Basiert auf guter Infrastruktur lokaler Datennetze

%section{"data-markdown" => ""}
  \### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section
  %h3 Interaktive Systeme
  %ul
    %li Strukturierung von Mensch-Computer-Interaktionen
    %li MÃ¶glichst gute Schnittstellen fÃ¼r die Benutzer schaffen
    %li Der eigentliche Systemkern bleibt von der Benutzerschnittstelle unangetastet.

%section{"data-markdown" => ""}
  \### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section
  %h3 Adaptive Systeme
  %ul
    %li UnterstÃ¼tzung der Erweiterungs- und AnpassungsfÃ¤higkeit von Softwaresystemen.
    %li Das System sollte von vornherein mÃ¶gliche Erweiterungen unterstÃ¼tzen
    %li Die KernfunktionalitÃ¤t sollte davon unberÃ¼hrt bleiben kann.

%section{"data-markdown" => ""}
  \### Adaptive Systeme
  \#### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \### Anti-Patterns

%section{"data-markdown" => ""}
  \#### Anti-Patterns?
  Ein Anti-Pattern ist in der Softwareentwicklung ein hÃ¤ufig anzutreffender schlechter LÃ¶sungsansatz fÃ¼r
  ein bestimmtes Problem. Es bildet damit das GegenstÃ¼ck zu den Mustern (Entwurfsmuster, Analysemuster,
  Architekturmuster, â€¦), welche allgemein Ã¼bliche und bewÃ¤hrte ProblemlÃ¶sungsansÃ¤tze beschreiben.

%section{"data-markdown" => ""}
  \### Ãœberblick Ã¼ber Antipatterns
  \#### Projektmanagement Anti-Patterns
  \#### Architektur Anti-Pattern
  \#### Code Smells
  \#### Organisations Anti-Pattern

%section{"data-markdown" => ""}
  \#### Projektmanagement Anti-Patterns
  \### Blendwerk
  \### AufgeblÃ¤hte Software
  \### Feature creep
  \### Scope creep
  \### Brooksâ€™sches Gesetz
  \### Death Sprint
  \### Death March

%section{"data-markdown" => ""}
  \#### Architektur Anti-Patterns
  \### Big Ball of Mud
  \### Gasfabrik
  \### Gottobjekt
  \### Innere-Plattform-Effekt
  \### Spaghetticode
  \### Sumo-Hochzeit

%section{"data-markdown" => ""}
  \#### Code Smells
  \### Zwiebel
  \### Copy and Paste
  \### Lavafluss
  \### Magische Werte
  \### Reservierte WÃ¶rter
  \### Unbeabsichtigte KomplexitÃ¤t

%section{"data-markdown" => ""}
  \#### Organisations Anti-Pattern
  \### Wunderwaffe
  \### Das Rad neu erfinden
  \### Das quadratische Rad neu erfinden
  \### Body ballooning
  \### Empire building
  \### Warme Leiche
  \### Single head of knowledge

%section{"data-markdown" => ""}
  \#### Organisations Anti-Pattern II
  \### Management nach Zahlen
  \### Vendor Lock-In
  \### Design by Committee
  \### Boat Anchor
  \### Dead End
  \### Swiss Army Knife

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section{"data-markdown" => ""}
  \##### Layers
  Das Layers-Muster trennt eine Architektur in verschiedene Schichten, von denen jede eine Unteraufgabe auf einer bestimmten Abstraktionsebene realisiert.

%section{"data-markdown" => ""}
  \##### Layers
  \### Beispiel: ISO/OSI-Referenzmodell
  Netzwerk-Protokolle sind wahrscheinlich die bekanntesten Beispiele fÃ¼r geschichtete Architekturen.
  Das ISO/OSI-Referenzmodell teilt Netzwerk-Protokolle in 7 Schichten auf, von denen jede Schicht
  fÃ¼r eine bestimmte Aufgabe zustÃ¤ndig ist:

%section{"data-markdown" => ""}
  \##### Beispiel: ISO/OSI-Referenzmodell

  ![](/images/isoosi.png)

%section
  %h5 Layers
  %h3 Vorteile
  %ul
    %li Wiederverwendung und Austauschbarkeit von Schichten
    %li UnterstÃ¼tzung von Standards
    %li Einkapselung von AbhÃ¤ngigkeiten

%section
  %h5 Layers
  %h3 Nachteile
  %ul
    %li Geringere Effizienz
    %li Mehrfache Arbeit (z.B. Fehlerkorrektur)
    %li Schwierigkeit, die richtige Anzahl Schichten zu bestimmen

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h5 Pipes and Filters
  %h4 Eine Pipes-and-Filter Architektur eignet sich fÃ¼r Systeme, die DatenstrÃ¶me verarbeiten.

%section{"data-markdown" => ""}
  \##### Pipes and Filters

  ![](/images/filters1.png)

%section
  %h5 Pipes and Filters

  Das Pipes-and-Filters Muster strukturiert Systeme, in dem Kontext â€žVerarbeitung von
  DatenstrÃ¶menâ€œ. Die Verarbeitungsschritte werden in Filter eingekapselt und lassen sich
  so beliebig anordnen und getrennt voneinander entwickeln.

%section
  %h5 Pipes and Filters
  Der Kommandointerpreter sowie viele Werkzeuge
  des Unix Betriebssystems sind nach dem Pipes-and-
  Filter Muster gebaut. Die Ausgabe des einen dient
  als Eingabe fÃ¼r das nÃ¤chste Werkzeug:

%section
  %h5 Pipes and Filters
  %h4 Vorteile
  %ul
    %li FlexibilitÃ¤t durch Austausch und HinzufÃ¼gen von Filtern
    %li FlexibilitÃ¤t durch Neuanordnung
    %li Wiederverwendung einzelner Filter
    %li Rapid Prototyping von Pipeline Prototypen
    %li Zwischendateien sind nicht notwendig aber so gewÃ¼nscht mÃ¶glich
    %li Parallel-Verarbeitung mÃ¶glich

%section
  %h5 Pipes and Filters
  %h4 Nachteile
  %ul
    %li Die Kosten der DatenÃ¼bertragung zwischen den Filtern kÃ¶nnen je nach Pipe sehr hoch sein
    %li HÃ¤ufig Ã¼berflÃ¼ssige Datentransformationen zwischen den einzelnen Filterstufen
    %li Fehlerbehandlung Ã¼ber Filterstufen hinweg ist teilweise schwierig
    %li Gemeinsamer Zustand (z.B. Symboltabelle in Compilern) ist teuer und unflexibel
    %li Effizienzsteigerung durch Parallelisierung oft nicht mÃ¶glich (z.B. da Filter aufeinander warten oder nur ein Prozessor arbeitet)

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \### Blackboard
  \#### Domain-driven Design

%section
  %h5 Blackboard

  Das Blackboard Muster wird angewendet bei Problemen, die nicht auf eine eindeutige
  LÃ¶sungsstrategie hindeuten. Den Kontext fÃ¼r â€žBlackboardâ€œ bilden somit Problembereiche,
  fÃ¼r die es noch keine festgelegten LÃ¶sungsstrategien gibt. Beispiele hierfÃ¼r sind
  Spracherkennungs-, Bildverarbeitungs-, sowie Ãœberwachungssysteme.

%section{"data-markdown" => ""}
  \##### Blackboard

  ![](/images/blackboard.png)

%section
  %h5 Blackboard
  Das Schwarzes Brett dient als zentrale Datenstruktur. Agenten verarbeiten vorhandenes und
  bringen neues Wissen. Eine Steuerung entscheidet, welcher Agent die Bedingung zum Ermitteln
  von neuem Wissen erfÃ¼llt und somit das Programm der LÃ¶sung einen Schritt nÃ¤her bringen kÃ¶nnte,
  dann aktiviert es den Agenten.

%section
  %h5 Blackboard
  Die Zugriffe von Agenten auf das schwarze Brett stellen die Konnektoren da. Die Agenten
  sind vÃ¶llig entkoppelt und kÃ¶nnen auch zur Laufzeit hinzugefÃ¼gt und ausgetauscht
  werden, ohne dass andere Agenten betroen sind. Die parallele AusfÃ¼hrung von Agenten ist ebenfalls mÃ¶glich.

%section
  %h5 Blackboard
  Das Programmverhalten von Systemen, fÃ¼r die solch eine Architektur eingesetzt wird, ist
  hochgradig nichtdeterministisch und daher schwer prÃ¼fbar. Im Bereich Robotersteuerung und
  Mustererkennung (Bild, Ton, Sprache, Schrift) wird aufgrund der nichtdeterministischen
  ProblemlÃ¶sung die Black Board Architektur hÃ¤ufig verwendet.

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \### Domain-driven Design

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design ist nicht nur eine Technik oder Methode. Es ist viel mehr eine Denkweise und
    Priorisierung zur Steigerung der ProduktivitÃ¤t von Softwareprojekten im Umfeld komplexer fachlicher
    ZusammenhÃ¤nge

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design basiert auf folgenden zwei Annahmen:
  %ul
    %li Der Schwerpunkt des Softwaredesigns liegt auf der Fachlichkeit und der Fachlogik.
    %li Der Entwurf komplexer fachlicher ZusammenhÃ¤nge sollte auf einem Modell der AnwendungsdomÃ¤ne, dem DomÃ¤nenmodell basieren.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Literatur
  \### "Domain-Driven Design. Tackling Complexity in the Heart of Software"
  *(Eric Evans)*

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur


%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### "SOA ist ein Paradigma fÃ¼r die Strukturierung und Nutzung verteilter FunktionalitÃ¤t, die von unterschiedlichen Besitzern verantwortet wird."

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * SOA soll Dienste von IT-Systemen strukturieren und zugÃ¤nglich machen.
  * SOA orientiert sich an GeschÃ¤ftsprozessen
  * GeschÃ¤ftsprozesse sind die Grundlage fÃ¼r konkrete Serviceimplementierungen

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Vorteile
  * Eine agile IT-Umgebung, die schnell auf geschÃ¤ftliche VerÃ¤nderungen reagieren kann
  * Niedrigere Gesamtbetriebskosten durch die Wiederverwendung von Services
  * HÃ¶here Leistung, grÃ¶ÃŸere Skalierbarkeit und Transparenz
  * Dienstleistungen und Produkte kÃ¶nnen schneller auf den Markt gebracht werden

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Nachteile
  * SOA wird von Marketingabteilungen gehyped: EinfÃ¼hrung von SOA ist die LÃ¶sung aller bisherigen Probleme
  * SOA generiert einen hÃ¶heren Aufwand als bisherige monolithische Programmstrukturen.
  * SOA erzeugt im Code wesentlich komplexere AblÃ¤ufe
  * SOA setzt fÃ¼r die beteiligten Entwickler ein erhebliches Know-how voraus.
  * _Somit sind Entwickler auch nicht so einfach ersetzbar, und die AbhÃ¤ngigkeit der Unternehmen von einzelnen Entwicklern steigt deutlich._


%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### In einem reinen Peer-to-Peer-Netz sind alle Computer gleichberechtigt und kÃ¶nnen sowohl Dienste in Anspruch nehmen, als auch zur VerfÃ¼gung stellen.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer
  ![](/images/PeerToPeer.jpg)

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Vorteile
  * alle Computer sind gleichberechtigt
  * KostengÃ¼nstiger als Servernetzwerke
  * Kein leistungsstarker zentraler Server erforderlich
  * Keine spezielle Netzwerksoftware erforderlich
  * Benutzer verwalten sich selbst
  * Keine hierarchische Netzwerkstruktur

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Nachteile
  * Zentrale Sicherheitsaspekte sind nicht von Bedeutung
  * Sehr schwer zu administrieren
  * kein einziges Glied im System ist verlÃ¤sslich

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \### Client-Server

%section{"data-markdown" => ""}
  \#### Client-Server

  \### Das Client-Server-Modell verteilt Aufgaben und Dienstleistungen innerhalb eines Netzwerkes.

%section{"data-markdown" => ""}
  \#### Client-Server

  * Der Client kann auf Wunsch einen Dienst vom Server anfordern
  * Der Server beantwortet die Anforderung.
  * Ãœblicherweise kann ein Server gleichzeitig fÃ¼r mehrere Clients arbeiten.

%section{"data-markdown" => ""}
  \#### Client-Server
  ![](/images/client-server.jpg)

%section{"data-markdown" => ""}
  \#### Client-Server

  * Ein Server ist ein Programm, das einen Dienst (Service) anbietet.
  * Ein anderes Programm, der Client, kann diesen Dienst nutzen.
  * Die Kommunikation zwischen Client und Server ist abhÃ¤ngig vom Dienst
  * Der Dienst bestimmt, welche Daten zwischen beiden ausgetauscht werden.
  * Der Server ist in Bereitschaft, um jederzeit auf die Kontaktaufnahme eines Clients reagieren zu kÃ¶nnen.
  * Der Server ist passiv und wartet auf Anforderungen.
  * Die Regeln der Kommunikation fÃ¼r einen Dienst werden durch ein fÃ¼r den jeweiligen Dienst spezifisches Protokoll festgelegt.

%section{"data-markdown" => ""}
  \#### Client-Server

  * Clients und Server kÃ¶nnen als Programme auf verschiedenen Rechnern oder auf demselben Rechner ablaufen.
  * Das Konzept kann zu einer Gruppe von Servern ausgebaut werden, die eine Gruppe von Diensten anbietet.
  * In der Praxis laufen Server-Dienste meist gesammelt auf bestimmten Rechnern, die dann selber "Server" genannt werden

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Vorteile
  * Gute Skalierbarkeit
  * Einheitliches Auffinden von Objekten

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Nachteile
  * Der Server muss immer in Betrieb sein
  * Der Server muss gegen Ausfall und Datenverlust gesichert werden

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  Das MVC-Pattern ist eine spezielle Variante des Layers-Pattern, die sich aus den
  drei Schichten Datenhaltung (Model), Programmlogik (Controller) und PrÃ¤sentation (View) zusammensetzt.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  * Model: Speicherung und Zugriffskontrolle von Daten
  * View: Darstellung der Daten fÃ¼r die Anwender
  * Controller: Vermittlung zwischen View und Model

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  ![](/images/mvc.png)


%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Model

  * Das Modell kapselt Kerndaten und FunktionalitÃ¤t.
  * Das Modell ist unabhÃ¤ngig von einer bestimmten Darstellung der Ausgabe oder einem bestimmten Verhalten der Eingabe.
  * Das Modell bildet die KernfunktionalitÃ¤t der Anwendung ab.
  * (Das Modell benachrichtigt registrierte bei DatenÃ¤nderungen.)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: View

  * Die Sicht (view) zeigt dem Benutzer Informationen an.
  * Es kann mehrere Sichten pro Modell geben.
  * Ggf. zugeordnete Eingabeelemente anzeigen

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Controller

  * Der Controller verarbeitet Eingaben und ruft passende Dienste der zugeordeten Sicht oder des Modells auf.
  * Jede Controller ist einer Sicht zugeordnet
  * Es kann mehrere Controller pro Modell geben.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Vorteile

  * Mehrere Sichten desselben Modells
  * Automatische Synchronisation aller Views
  * Austauschbarkeit von Views und Controllern
  * Gute Trennung von Modell und View
  * Potential fuÌˆr vorgefertigte Frameworks

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Nachteile
  * ErhÃ¶hte KomplexitÃ¤t
  * Starke Kopplung zwischen Modell und View
  * Starke Kopplung zwischen Modell und Controller
  * Potential fuÌˆr unnÃ¶tig hÃ¤ufige Aktualisierungen
  * HÃ¤ufig ineffizienter Datenzugriff auf das Modell.
  * View und Controller sind schwer zu portieren.

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Presenter

  \### Hervorgegangen aus dem Model-View-Controller (MVC) Architekturmuster.

  VollstÃ¤ndige Trennung von Model und View, Verbindung Ã¼ber einen Presenter.

%section{"data-markdown" => ""}
  \#### Model View Presenter

  * VollstÃ¤ndige Trennung von Model und View
  * Deutlich verbesserte Testbarkeit
  * Strenge Trennung der einzelnen Komponenten

%section{"data-markdown" => ""}
  \#### Model View Presenter (MVP)
  ![](/images/mvp.png)

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hohe FlexibilitÃ¤t fÃ¼r ein System, das aus vielen autarken Einzelsystemen zusammengesetzt ist.

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  * GroÃŸe Systeme, fÃ¼r die das Model-View-Controller-Muster nicht ausreicht
  * Aufteilung des Systems in zwei Richtungen
  * --> In die drei Einheiten Presentation, Control und Abstraction (Ã¤hnlich dem MVC)
  * --> Hierarchisch in verschiedene Teile (â€žAgentenâ€œ), die jeweils einen Teil der Aufgaben des Systems anbieten

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \### Adaptive Systeme

%section{"data-markdown" => ""}
  \##### Adaptive Systeme
  \### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Ziel: Ã„nderung von Systemanforderungen zur Laufzeit dynamisch begegnen.

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Aufgaben
  * Der Mikrokernel bietet die Basis fÃ¼r mÃ¶gliche Erweiterungen
  * Der Microkernel koordiniert die Zusammenarbeit.

%section{"data-markdown" => ""}
  \#### Microkernel
  \### Herausforderung

  ![](/images/microkernel.png)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Vorteile

  * Separierte Komponenten: Austauschbarkeit
  * Treiber im Benutzer-Modus: Sicherheit
  * kleine Trusted Computing Base
  * Skalierbarkeit
  * ZuverlÃ¤ssigkeit
  * Transparenz

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Nachteile

  * Leistung
  * KomplexitÃ¤t


%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### Nutzen von Templates

  Beispiele:
  * arc42
  * Normen
  * Software Guidebook

%section{"data-markdown" => ""}
  \### ARC42
  \#### (Dr. Gernot Starke / Dr. Peter Hruschka)
  http://www.arc42.de/

  \#### *arc42 unterstÃ¼tzt Software- und Systemarchitekten. Es kommt aus der Praxis und basiert auf Erfahrungen internationaler Architekturprojekte und RÃ¼ckmeldungen vieler Anwender.*

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### ARC42

  1. EinfÃ¼hrung und Ziele
  2. Randbedingungen
  3. Kontextabgrenzung
  4. LÃ¶sungsstrategie
  5. Bausteinsicht
  6. Laufzeitsicht
  7. Verteilungssicht
  8. Querschnittliche Konzepte/Muster
  9. Entwurfsentscheidungen
  10. QualitÃ¤tsszenarien
  11. Risiken
  12. Glossar

%section{"data-markdown" => ""}
  \#### ARC42
  ![](/images/arc42.png)

%section{"data-markdown" => ""}
  \### IEEE Standards

  **IEEE Standards** documents are developed within the IEEE Societies and the Standards Coordinating Committees of
  the IEEE Standards Association (IEEE-SA) Standards Board. The IEEE develops its standards through a consensus
  development process, approved by the American National Standards Institute, which brings together volunteers representing
  varied viewpoints and interests to achieve the final product. Volunteers are not necessarily members of the
  Institute and serve without compensation. While the IEEE administers the process and establishes rules to promote
  fairness in the consensus development process, the IEEE does not independently evaluate, test, or verify the accuracy
  of any of the information contained in its standards or implementations thereof.

%section{"data-markdown" => ""}
  \### IEEE Standards

  * IEEE 802:    LAN
  * IEEE 802.3:  Carrier sense multiple access with collision detection (CSMA/CD)
  * IEEE 802.11: Wireless LAN
  * IEEE 830:    Recommended Practice for Software Requirements Specifications
  * IEEE 1394:   FireWire/i.Link Bussysteme
  * IEEE 1471:   Recommended Practice for Architectural Description of Software-Intensive Systems
  * IEEE 9945:   Portable Operating System Interface (POSIXÂ®)

%section{"data-markdown" => ""}
  \### IEEE Standards - Kosten

  * IEEE 830: 171$
  * Journals: 26.500$ / Jahr
  * Standards Library: *custom quote*

%section{"data-markdown" => ""}
  \### Software Guidebook

  * Template von Simon Brown aus dem Buch *"Software Architecture for Developers"*
  * Buch: https://leanpub.com/software-architecture-for-developers
  * Beispiel: https://leanpub.com/techtribesje (kostenlos)

%section{"data-markdown" => ""}
  \### Software Guidebook

  \#### Welche Informationen wÃ¼nsche ich mir, wenn ich in ein neues Projekt komme?

  * Karten
  * Sichten
  * Geschichte
  * Praktische Informationen!

%section{"data-markdown" => ""}
  \### Software Guidebook
  \## Product vs project documentation

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \#### Dokumentation von Architekturen
  \### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Frameworks
  \## Was ist ein Framework?

%section{"data-markdown" => ""}
  \## Frameworks

  \### Ein Framework ist kein fertiges Programm, es stellt einen Rahmen zur VerfÃ¼gung.

%section{"data-markdown" => ""}
  \## Frameworks

  * Ein Framework ist eine semi-vollstÃ¤ndige Applikation.
  * Es stellt fÃ¼r Applikationen eine wiederverwendbare, gemeinsame Struktur zur VerfÃ¼gung.
  * Entwickler integrieren dass Framework in ihre eigene Applikation ein, und erweitern es um die Applikationslogik.
  * Frameworks stellen eine kohÃ¤rente Struktur zur VerfÃ¼gung, anstatt eine einfache Menge von Hilfsklassen anzubieten.

%section{"data-markdown" => ""}
  \## Frameworks

  * Ein Framework gibt in der Regel die Anwendungsarchitektur vor.
  * Ein Framework definiert den Kontrollfluss der Anwendung
  * Ein Framework definierte die Schnittstellen fÃ¼r die Applikation.

%section{"data-markdown" => ""}
  \## Frameworks

  \### Eine allgemeingÃ¼ltige Definition von Frameworks gibt es aufgrund der hohen Anzahl von DiversitÃ¤ten nicht.

%section{"data-markdown" => ""}
  \### Frameworks

  \## Vorteile

  * Wiederverwendung von Code
  * GrundfunktionalitÃ¤t muss nicht immer wieder implementiert werden
  * Es existieren genormte Schnittstellen z.B. zu Datenbanken
  * Frameworks erleichtern die Programmierarbeit und sparen Entwicklungszeit
  * Frameworks kÃ¶nnen den Stil entscheidend verbessern

%section{"data-markdown" => ""}
  \### Frameworks

  \## Nachteile
  * Frameworks erhÃ¶hen die KomplexitÃ¤t der Anwendung
  * Frameworks stecken voller Know-How und eine effiziente Anwendung erfordert Profiwissen
  * Frameworks nehmen nicht das VerstÃ¤ndnis der Grundlagen ab, auch wenn oft so gearbeitet wird
  * Dokumentationen sind grÃ¶ÃŸtenteils unzureichend



%section{"data-markdown" => ""}
  \## Frameworks
  Wie wÃ¤hle ich ein Framework aus?


%section{"data-markdown" => ""}
  \###	PopularitÃ¤t und Community
  *Wie wahrscheinlich finde ich Hilfe und Entwickler?*

%section{"data-markdown" => ""}
  \### Philosophie
  *A tool developed by professionals for their own needs will obviously meet the demands of other professionals.*

%section{"data-markdown" => ""}
  \### Sustainability / Nachhaltigkeit
  *Kann das Framework "mitwachsen"?*

%section{"data-markdown" => ""}
  \### Support
  *Gibt es professionelle Hilfe neben der Community?*

%section{"data-markdown" => ""}
  \### Technik
  *Wie gut ist das Framework implementiert?*

%section{"data-markdown" => ""}
  \### Security
  *Wie schnell werden SicherheitslÃ¼cken reportet und geschlossen?*

%section{"data-markdown" => ""}
  \### Dokumentation
  *Wie gut, ausfÃ¼hrlich und verstÃ¤ndlich ist das Framework dokumentiert? Wie aktuell ist die Doku?*

%section{"data-markdown" => ""}
  \### Lizenz
  *Ein Framework unter GPL Lizenz verlangt z.B., dass die Anwendung auch unter der GPL steht. MIT dagegen nicht.*

%section{"data-markdown" => ""}
  \### Entwickler-KapazitÃ¤t
  *Wie wahrscheinlich werde ich Entwickler finden?*

%section{"data-markdown" => ""}
  \### Hosting Requirements
  *Wie einfach kann ich die Anwendung deployen?*

%section{"data-markdown" => ""}
  \### Einfache Installation?
  *Wie schnell ist ein neues Projekt eingerichtet?*

%section{"data-markdown" => ""}
  \### Lernkurve
  *Wie komplex ist das Framework?*

%section{"data-markdown" => ""}
  \### Inhalte / Funktionen?

  * AJAX
  * Authentication
  * Authorization
  * Caching
  * Data Validation
  * Templating engine
  * URL mapping / rewriting
  * ...?

%section{"data-markdown" => ""}
  \### DB Abstraktion / ORM
  *Wie einfach/mÃ¤chtig ist das Object Relational Mapping?*

%section{"data-markdown" => ""}
  \### JS Library
  *Welche JS Bibliothek ist per default dabei?*

%section{"data-markdown" => ""}
  \### Unit Testing
  *Wie sehr ist TDD Teil der Philosophie, wie ist der Tool-Support?*

%section{"data-markdown" => ""}
  \### Skalierbarkeit?
  *Wie einfach lÃ¤sst sich die Anwendung bei Bedarf skalieren?*

%section{"data-markdown" => ""}
  \### Ausprobieren!
  *Reviews lesen reicht nicht, Erfahrungen und das look&feel zÃ¤hlen!*

%section{"data-markdown" => ""}
  \### Wann brauche ich ein Framework?

  * Die Anwendung basiert im Wesentlichen auf CRUD Operationen
  * Die Anwendung wird relativ groÃŸ
  * UI und Anwendungslogik sollen getrennt werden
  * Authentication und andere Grundfunkionen werden intensiv genutzt
  * Zeitdruck + Das Framework ist bereits bekannt

%section{"data-markdown" => ""}
  \### Wann brauche ich KEIN Framework?

  * Ich brauche nur einen kleinen Teil des Frameworks (z.B. ORM)
  * Zeitdruck + Das Framework ist nicht bekannt
  * "Frameworks lÃ¶sen jedes Problem"

%section{"data-markdown" => ""}

  \### Vorbereitung auf Klausuraufgaben

%section{"data-markdown" => ""}

  \### Was ist NICHT Klausrelevant?

  * UML
  * Details zu konkreten Frameworks oder Technologien

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben
  \### Grundlagen & Geschichte
  * Was waren die GrÃ¼nde fÃ¼r Softwarearchitektur?
  * Nennen Sie drei typische Aufgaben von Softwarearchitekten
  * Welche nicht-funktionalen Anforderungen sollten Sie beim Architekturentwurf ggf. berÃ¼cksichtigen?
  * Was besagt das Brook'sche Gesetz?
  * Was besagt 'Conways Law'?
  * In welcher Beziehung stehen Architektur und Design?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben
  \### Sichten

  * Welche Arten von Sichten gibt es?
  * Was sollte eine Kontext-Sicht enthalten?
  * Was enthÃ¤lt eine Verteilungssicht?
  * Sind mehr als die vier klassischen Sichten sinnvoll?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben
  \### Architekturmuster

  * Welche Aufgabe haben Architekturmuster?
  * Nennen und erlÃ¤utern Sie drei Arten von Architekturmustern
  * Nennen und erlÃ¤utern Sie drei Anti-Patterns
  * FÃ¼r welche Systeme wÃ¼rden Sie eine Blackboard-Architektur verwenden?
  * FÃ¼r welche Systeme wird das MVC Muster typischerweise verwendet?
  * FÃ¼r welche Systeme wird das MVP Architekturmuster typischerweise verwendet?
  * FÃ¼r welche Systeme wird das Microkernel Architekturmuster typischerweise verwendet?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben
  \### Dokumentation

  * Was ist der Grundgedanke hinter dem "Software Guidebook"?
  * Wie ist das ARC42 Template entstanden?

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben
  \### Frameworks

  * Was ist ein Framework?
  * Wann ist die Verwendung eines Frameworks sinnvoll?
  * Wann ist die Verwendung eines Frameworks nicht sinnvoll?
  * Nennen sie drei Vorteile fÃ¼r die Verwendung von Frameworks!
  * Nennen sie drei Nachteile fÃ¼r die Verwendung von Frameworks!
  * Nennen sie drei Auswahlkriterien fÃ¼r Frameworks!
  * Was ist Dependency Injection?
  * Nennen Sie drei Beispiele fÃ¼r Crosscutting Concerns

%section{"data-markdown" => ""}
  \### Klausur

  * 7.7.2016
  * 90 Minuten
  * keine Hilfsmittel

%section{"data-markdown" => ""}
  \## Fragen?
  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
