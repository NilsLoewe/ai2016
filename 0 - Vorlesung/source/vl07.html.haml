---
title: Vorlesung 7 - Architekturmuster
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule für angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils Löwe / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \## 3. Praktikum
  [Praktikum 3: Architekturentwurf](https://ai2016.nils-loewe.de/p03.html)
  \### Fragen?

%section{"data-markdown" => ""}
  \### Wiederholung
  \### Architekturmuster

%section
  %h4
    Ein Architekturmuster beschreibt eine bewährte Lösung für ein wiederholt auftretendes Entwurfsproblem
  %p
    %i (Effektive Softwarearchitekturen)

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \### Domain-driven Design

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design ist nicht nur eine Technik oder Methode. Es ist viel mehr eine Denkweise und
    Priorisierung zur Steigerung der Produktivität von Softwareprojekten im Umfeld komplexer fachlicher
    Zusammenhänge

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design basiert auf folgenden zwei Annahmen:
  %ul
    %li Der Schwerpunkt des Softwaredesigns liegt auf der Fachlichkeit und der Fachlogik.
    %li Der Entwurf komplexer fachlicher Zusammenhänge sollte auf einem Modell der Anwendungsdomäne, dem Domänenmodell basieren.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Bestandteile des Domänenmodells
  %p Domain-driven Design unterscheidet die folgenden Bestandteile des Domänenmodells:
  %br
  ![](/images/DomainDrivenDesign_map.png)

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \### Architekturtechniken
  \#### Evolvierende Struktur (evolving order)
  \#### Systemmetapher (system metaphor)
  \#### Verantwortlichkeitsschichten (responsibility layers)
  \#### Wissenslevel (knowledge level)
  \#### Erweiterungsframeworks (pluggable component framework)

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### "SOA ist ein Paradigma für die Strukturierung und Nutzung verteilter Funktionalität, die von unterschiedlichen Besitzern verantwortet wird."

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * SOA soll Dienste von IT-Systemen strukturieren und zugänglich machen.
  * SOA orientiert sich an Geschäftsprozessen
  * Geschäftsprozesse sind die Grundlage für konkrete Serviceimplementierungen

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \#### Beispiel für einen Geschäftsprozess: **„Vergib einen Kredit“**

  * Auf einer hohen Ebene angesiedelt
  * Zusammengesetzt aus
  * _„Eröffnen der Geschäftsbeziehung“_
  * _„Eröffnen eines oder mehrerer Konten“_
  * _„Kreditvertrag“_

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * Ein Dienst ist eine IT-Repräsentation von fachlicher Funktionalität.
  * Ein Dienst ist in sich abgeschlossen (autark) und kann eigenständig genutzt werden.
  * Ein Dienst ist in einem Netzwerk verfügbar.
  * Ein Dienst hat eine wohldefinierte veröffentlichte Schnittstelle (Vertrag). Für die Nutzung reicht es, die Schnittstelle zu kennen. Kenntnisse über die Details der Implementierung sind hingegen nicht erforderlich.

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Vorteile
  * Eine agile IT-Umgebung, die schnell auf geschäftliche Veränderungen reagieren kann
  * Niedrigere Gesamtbetriebskosten durch die Wiederverwendung von Services
  * Höhere Leistung, größere Skalierbarkeit und Transparenz
  * Dienstleistungen und Produkte können schneller auf den Markt gebracht werden

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Nachteile
  * SOA wird von Marketingabteilungen gehyped: Einführung von SOA ist die Lösung aller bisherigen Probleme
  * SOA generiert einen höheren Aufwand als bisherige monolithische Programmstrukturen.
  * SOA erzeugt im Code wesentlich komplexere Abläufe
  * SOA setzt für die beteiligten Entwickler ein erhebliches Know-how voraus.
  * _Somit sind Entwickler auch nicht so einfach ersetzbar, und die Abhängigkeit der Unternehmen von einzelnen Entwicklern steigt deutlich._

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### In einem reinen Peer-to-Peer-Netz sind alle Computer gleichberechtigt und können sowohl Dienste in Anspruch nehmen, als auch zur Verfügung stellen.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer
  ![](/images/PeerToPeer.jpg)

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \#### Typische Eigenschaften:

  * Hohe Heterogenität bezüglich der Bandbreite, Rechenkraft, Online-Zeit
  * Die Verfügbarkeit und Verbindungsqualität der Peers kann nicht vorausgesetzt werden
  * Peers bieten Dienste und Ressourcen an und nehmen Dienste anderer Peers in Anspruch
  * Dienste und Ressourcen können zwischen allen teilnehmenden Peers ausgetauscht werden.
  * Peers haben eine signifikante Autonomie (über die Ressourcenbereitstellung).
  * Das P2P-System ist selbstorganisierend.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Vorteile
  * alle Computer sind gleichberechtigt
  * Kostengünstiger als Servernetzwerke
  * Kein leistungsstarker zentraler Server erforderlich
  * Keine spezielle Netzwerksoftware erforderlich
  * Benutzer verwalten sich selbst
  * Keine hierarchische Netzwerkstruktur

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Nachteile
  * Zentrale Sicherheitsaspekte sind nicht von Bedeutung
  * Sehr schwer zu administrieren
  * kein einziges Glied im System ist verlässlich

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \### Client-Server

%section{"data-markdown" => ""}
  \#### Client-Server

  \### Das Client-Server-Modell verteilt Aufgaben und Dienstleistungen innerhalb eines Netzwerkes.

%section{"data-markdown" => ""}
  \#### Client-Server

  * Der Client kann auf Wunsch einen Dienst vom Server anfordern
  * Der Server beantwortet die Anforderung.
  * Üblicherweise kann ein Server gleichzeitig für mehrere Clients arbeiten.

%section{"data-markdown" => ""}
  \#### Client-Server
  ![](/images/client-server.jpg)

%section{"data-markdown" => ""}
  \#### Client-Server

  * Clients und Server können als Programme auf verschiedenen Rechnern oder auf demselben Rechner ablaufen.
  * Das Konzept kann zu einer Gruppe von Servern ausgebaut werden, die eine Gruppe von Diensten anbietet.
  * In der Praxis laufen Server-Dienste meist gesammelt auf bestimmten Rechnern, die dann selber "Server" genannt werden

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Vorteile
  * Gute Skalierbarkeit
  * Einheitliches Auffinden von Objekten

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Nachteile
  * Der Server muss immer in Betrieb sein
  * Der Server muss gegen Ausfall und Datenverlust gesichert werden

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  Das MVC-Pattern ist eine spezielle Variante des Layers-Pattern, die sich aus den
  drei Schichten Datenhaltung (Model), Programmlogik (Controller) und Präsentation (View) zusammensetzt.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  * Model: Speicherung und Zugriffskontrolle von Daten
  * View: Darstellung der Daten für die Anwender
  * Controller: Vermittlung zwischen View und Model

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  ![](/images/mvc.png)


%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Model

  * Das Modell kapselt Kerndaten und Funktionalität.
  * Das Modell ist unabhängig von einer bestimmten Darstellung der Ausgabe oder einem bestimmten Verhalten der Eingabe.
  * Das Modell bildet die Kernfunktionalität der Anwendung ab.
  * (Das Modell benachrichtigt registrierte bei Datenänderungen.)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: View

  * Die Sicht (view) zeigt dem Benutzer Informationen an.
  * Es kann mehrere Sichten pro Modell geben.
  * Ggf. zugeordnete Eingabeelemente anzeigen

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Controller

  * Der Controller verarbeitet Eingaben und ruft passende Dienste der zugeordeten Sicht oder des Modells auf.
  * Jede Controller ist einer Sicht zugeordnet
  * Es kann mehrere Controller pro Modell geben.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Vorteile

  * Mehrere Sichten desselben Modells
  * Automatische Synchronisation aller Views
  * Austauschbarkeit von Views und Controllern
  * Gute Trennung von Modell und View
  * Potential für vorgefertigte Frameworks

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Nachteile
  * Erhöhte Komplexität
  * Starke Kopplung zwischen Modell und View
  * Starke Kopplung zwischen Modell und Controller
  * Potential für unnötig häufige Aktualisierungen
  * Häufig ineffizienter Datenzugriff auf das Modell.
  * View und Controller sind schwer zu portieren.

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Presenter

  \### Hervorgegangen aus dem Model-View-Controller (MVC) Architekturmuster.

  Vollständige Trennung von Model und View, Verbindung über einen Presenter.

%section{"data-markdown" => ""}
  \#### Model View Presenter

  * Vollständige Trennung von Model und View
  * Deutlich verbesserte Testbarkeit
  * Strenge Trennung der einzelnen Komponenten

%section{"data-markdown" => ""}
  \#### Model View Presenter (MVP)
  ![](/images/mvp.png)

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hohe Flexibilität für ein System, das aus vielen autarken Einzelsystemen zusammengesetzt ist.

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  * Große Systeme, für die das Model-View-Controller-Muster nicht ausreicht
  * Aufteilung des Systems in zwei Richtungen
  * --> In die drei Einheiten Presentation, Control und Abstraction (ähnlich dem MVC)
  * --> Hierarchisch in verschiedene Teile („Agenten“), die jeweils einen Teil der Aufgaben des Systems anbieten

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Agenten

  * Stellen die erste Stufe der Strukturierung während des Architekturentwurfes dar
  * Aufteilung der gesamten Anforderungen auf einzelne Agenten
  * Aufbau der hierarchischen Struktur
  * Für jeden Agenten erfolgt dann eine Aufteilung in Presentation, Abstraction und Control

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hierarchie: Drei Schichten

  * Top-Level-Agent: Globale Aufgaben
  * Intermediate-Level-Agenten: Strukturierung der Bottom-Level-Agenten
  * Bottom-Level-Agenten: Konkrete, abgeschlossene Aufgaben

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Aufteilung der Agenten

  * Nicht jeder Agent muss alle drei Komponenten implementieren
  * Jeder Agent bringt die Benutzerschnittstelle und das Datenmodell für seine Aufgabe mit
  * Jeder Agent muss die Control implementieren, um über sie die Kommunikation mit anderen Agenten und zwischen den Komponenten zu ermöglichen

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Vorteile
  * Zerlegung der Funktionen des Gesamtsystems in einzelne semantisch getrennte Teile
  * Gute Erweiterbarkeit durch neue Agenten
  * Gute Wartbarkeit ist durch die interne Struktur der Agenten

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Nachteile
  * Erhöhte Systemkomplexität
  * Erhöhter Koordinations- und Kommunikationsaufwand zwischen den Agenten
  * Die Steuerungskomponenten können eine hohe Komplexität erreichen

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Domain Driven Design: Ein Beispiel

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Eine Firma bietet Softwareentwicklung als Dienstleistung an.

  \###### http://blog.mirkosertic.de/architecturedesign/dddexample

  * Aufwand wird nach Stunden verrechnet
  * Es gibt festangestellte Softwareentwickler
  * Es gibt einen Pool von Freelancern.
  * Bisher wird die Zuordnung von Entwicklern zu Projekten in einem Excel-Sheet organisiert


%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Probleme mit dem Excel-Ansatz

  * Excel skaliert nicht auf mehrere Anwender
  * Keine Sicherheit
  * Kein Logging

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel
  \### Lösung: Neue Software bauen

  * Durchsuchbarer Katalog von Freelancern
  * Mehrere Kontaktmöglichkeiten pro Freelancer
  * Durchsuchbarer Katalog von Projekten
  * Durchsuchbarer Katalog von Projekten
  * Timesheets für jeden Freelancer (pro Projekt)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddfirstrun.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Straight forward Ansatz
  * Kunden
  * Freelancer
  * Projekte
  * Timesheets
  * User Management: Rolle

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz
  \### Probleme?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Großer Objektgraph: Performance Probleme unter Last
  Framework wie Hibernate wäre notwendig um das zu vermeiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Warum die bidirektionale Verknüpfung zwischen User und Rolle?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Boolean-Flags um den Kontakttypen zu unterscheiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Projekt-Liste in der Freelancer-Klasse:
  \#### Freelancer verändern um Projekte zuzufügen
  Potentielle Transaktionsprobleme unter Last (mehrere Leute legen gleichzeitig Projekte für den gleichen Kunden an)

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  * Kontaktinformation == Kommunikationskanal?
  * Das Diagramm ist eher ein Entiy-Relationship-Diagram als ein Software Modell
  * Wo ist die Businesslogik?

%section{"data-markdown" => ""}
  \### DDD nutzen

  * Gemeinsame Sprache schaffen um zwischen Entwicklern und Domänenexperten zu vermitteln
  * Komplexität reduzieren durch OO-Design Prinzipien

%section{"data-markdown" => ""}
  \#### DDD nutzen
  \#### Anforderungen: "Body Leasing Domain"
  \### **Context-Map: Komplexität reduzieren durch Subdomains**

  * Identität und Access Management Subdomain
  * Freelancer Management Subdomain
  * Kundenmanagement Subdomain
  * Projektmanagement Subdomain

%section{"data-markdown" => ""}
  \#### DDD - Context Map
  ![](/images/dddcontextmap.png)

%section{"data-markdown" => ""}
  \#### DDD - Bounded Context

  * Zuordnen von Subdomains zu Teilen der Lösung
  * *Building blocks* nutzen (Design Pattern anwenden)
  * Die DDD Architekturpattern sind nicht technologieabhängig!

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddrevised.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Bounded Contexts für jede Subdomain
  * Bounded Contexts sind isoliert und unabhängig
  * Verbindungen durch common types (UserId, ProjectId, CustomerId): “Generic Subdomain”

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Jeder Bounded Context enthält Aggregates und Wertobjekte
  * Aggregates sind Objekthierarchien
  * Nur das Root-Objekt eines Aggregates ist von außen zugreifbar
  * Jeder Zugriff auf ein Objekt passiert durch die Aggregates: Bessere Kapselung
  * Aggregates und Entites besitzen eine ID
  * Wertobjekte haben keine ID und können ihren Zustand nicht ändern
  * Jede Zustandsänderung erzeugt ein neues Wertobjekt: Vermeiden von Seiteneffekten

%section{"data-markdown" => ""}
  \#### DDD - Beschreibung von Verhalten

  \### Use Case: “Freelancer zieht um”

%section{"data-markdown" => ""}
  \#### Entwurf ohne DDD

  ![](/images/dddbehavior.png)

%section{"data-markdown" => ""}
  \#### DDD - Probleme

  * Name etc. ändern durch Setter-Methoden
  * Setter können von diversen Orten aufgerufen werden
  * Rollenbasierte Security schwer umsetzbar
  * Kein Kontext des Aufrufers bekannt
  * Kein "Adress-Konzept", lediglich einzelne Felder

%section{"data-markdown" => ""}
  \#### Entwurf mit DDD

  ![](/images/dddbehaviorrevised.png)

%section{"data-markdown" => ""}
  \#### DDD Ansatz - Vorteile

  * Der Freelancer hat nur ein Attribut: Die Adresse
  * Eine Adresse ist immutable, Änderungen erzeugen neue Adress-Objekte
  * getAdress gibt ein immutable Adress-Objekt zurück
  * movedTo(Adress) bildet explizit den UseCase ab
  * Rollenbasierte Security ist möglich

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Persistenz in DDD wird mit "Repositories" umgesetet
  * Ein Repository ist durchsuchbar, kann Instanzen liefern und löschen, sowie neue Instanzen ablegen
  * Es sollte ein Repository für jedes Aggregate geben

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddusecasepersistence.png)

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Ein Client ist ein abstraktes Konzept
  * Ein Client kann alles von einem Frontend über einen SOAP Webservice zu einer REST Ressource sein
  * Ein Client sendet Befehle an den ApplciationService

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Der ApplicationService setzt die Befehle in UseCases um
  * Der FreelancerApplicationService lädt dasFreelancer Aggregate aus dem FreelancerRepository und ruft moveTo() auf dem FreelancerAggregate auf
  * Der FreelancerApplicationService bildet dabei die Transactionsgrenzen.
  * Jeder Aufruf erzeugt eine neue Transaktion

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  * Jeder Bounded Context sollte eine "Deployment Unit" bilden, z.B. ein Java WAR file oder ein EJB JAR
  * Die Bounded Contexts sind unabhängig designt, sie sollten daher auch unabhängig implementiert werden

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  \### Jede Deployment Unit enthält die folgenden Elemente:

  * Domain Layer: Domänenlogik
  * Infrastructure Layer: Technologieabhängige Artefakte (z.B. Hibernate für Repository)
  * Application Layer: Gateway zur Businesslogik mit Transaktionskontrolle

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer1.png)

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer2.png)

%section{"data-markdown" => ""}
  \#### DDD - Vorteile

  * Der Domain Layer basiert nicht auf anderen Teilen der Architektur
  * Die Repository Implementierung kann getauscht werden, ohne die Businesslogik zu beeinflusseng any business logic.

%section{"data-markdown" => ""}
  \#### DDD -  Domain Layer

  * Enthält die Businesslogik, keine Abhängigkeiten der Infrastruktur
  * Die Modelle sollten nach dem CQS(Command-Query-Separation) Prinzip entworfen werden
  * --> Query Methoden geben lediglich Daten zurück ohne Zustände zu ändern
  * --> Command Methoden ändern den Stade

%section{"data-markdown" => ""}
  \#### DDD - Application Layer

  * Der Application Layer nimmt Kommandos des User Interface Layer an
  * Der Application Layer ruft UseCase Implementierungen im Domain layer auf
  * Der Application Layer biete Transactioskontrolle für Business Operationen

TBD:
  * DDD Beispiel fertig
  * Rückblick auf Architekturmuster
  * Landkarte: Wie wähle ich denn nun das passende Muster aus?
  * Wie entwerfe ich die Architektur? --> Motivation für Dokumentation

%section{"data-markdown" => ""}
  \#### DDD - Infrastructure Layer

  * Der Infrastructure Layer bietet Infrastrukturabhängige Teile für alle anderen Layer


  Client / User Interface Layer
  The Client Layer consumes Application Services and invokes business logic on these services. Every invocation is a new transaction.

  The Client Layer can be almost anything, starting from an JSF 2.0 Backing Bean as the view controller to a SOAP webservice endpoint or a RESTful web resource. Even Swing, AWT or OpenDolphin/JavaFX can be used to create the user interface.

  Context Integration
  Now I want to write about Context Integration. What is this all about? Consider the following requirements of the body leasing domain:

  A Customer can only be deleted if there is no Project assigned
  Once a Timesheet is entered, the Customer needs to be billed
  Synchronous Integration
  Let's start with the first one. In this case, the Customer Management Bounded Context needs to check if there is a Project registered for a given Customer before a Customer can be deleted. This requires a kind of Synchronous Integration of the two Bounded Contexts.

  There are a lot of opportunities. First of all, we want to keep the context independent of each other. So how can we deal with that? Here is a design for the customer Bounded Context to interact with the Project Management Bounded Context:

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddsyncexample1.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  There is a new term: a Domain Service. What is a Domain Service? A Domain Service implements business logic which cannot be implemented by an Entity, Aggregate or ValueObject, because it does not belong there. For instance if the business logic invocation includes operation across multiple Domain Objects or in this case integration with another Bounded Context.

  The ApplicationService invokes the deleteCustomerById method of the CustomerService. The CustomerService asks the ProjectManagementAdapter by calling customerExists() if a Project exists for the given CustomerId. Only if it returns false, the Customer is removed from the CustomerRepository.

  There are two implementations of ProjectManagementAdapter available, a SOAP and a REST based one. We can either use SOAP to invoke a full webservice operation with XML marshalling and using the full JAX-WS stack, or we could use REST and call http://example.com/customers/customerId/projects and get a 404(not found) or 20x(Ok) HTTP response code. This is up to you, but the REST one would be less complicated, easier to integrate and also scales better. Also we can start with REST and switch to SOAP if it is required. It is quite easy to change the implementation without affecting the domain layer, we just use another implementation of the adapter.

  At the Project Management Bounded Context side, there is an ApplicationWebService exposed as a REST resource or SOAP service implementing the server part of the communication. This service or resource delegates to the ProjectApplication Serviec, which delegates to ProjectDomainService asking if there is a Project registered for a given CustomerId.

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddsyncexample2.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  In any case we have to take care of transaction boundaries. WebService or REST resource invocation do not promote transactions out of the box, and using XA/two-phase-commit would increase complexity and reduce scalability. It would be the best to not delete a customer physically and instead mark it as logically deleted. In case of transaction failure or concurrency issues it would be easy to restore the customer to its original state.

  Here you see also the reason why the Infrastructure Layer is located above all others. It must be able to delegate to it or implement technology specific artifacts based on interfaces defined in layers below.

  An asynchronous example
  Ok, now we continue with a more complex example. Consider the requirement, that once a Timesheet is entered, a Customer needs to be billed.

  This is a very interesting one. It is interesting because it does not require synchronous invocation. The bill can be sent just in time, or a few hours later or at the end of the month together with other bills. Or the bill can be enriched by the Customer's Key Account Manager or whatever, the Freelancer management context just does not care.

  How can we model this with DDD patterns? The key here is the phrase “once a Timesheet is…”, this is a business relevant Event in our domain, and such Events can be modeled as Domain Events!

  A Domain Event is created and forwarded to an Event Store and stored there for further processing. The EventStore is part of the Bounded Context Deployment Unit and storing the Event in the store is done under the running transaction managed by an ApplicationService. At infrastructure side, there is a Timer forwarding the stored Events to the final messaging infrastructure, for instance JMS or AMQP based, even invocation of a REST resource can be considered as message delivery.

  So why do we need the local EventStore? Well, the messaging infrastructure might become unavailable temporarily, but this should not affect our running Bounded Context. So the Events will be queued and delivered when the infrastructure is available again. If we would couple the messaging infrastructure directly with the Event producer, the producer might fail to send in case of an infrastructure error. Even if we use messaging, this might case a ripple effect over the whole infrastructure if something goes wrong, and this is the reason we use messaging: system decoupling

  Here is how the Freelancer Management Bounded Context is modeled:


%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddasyncexample1.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  The FreelancerService creates a TimesheetEntered Domain Event and forwards it to the EventStore, which is basically another Repository. Then, the JMSMessagingAdapter takes the pending Events from the EventStore and tries to forward them to the target messaging infrastructure till delivery succeeds. But this forwarding is handled in another transaction, and can be triggered by a timer, for instance.

  Ok, how does the Customer Management Context handle the Events? This is modeled as follows:


%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddasyncexample2.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  Again, the Infrastructure Layer must be located all other layers as it must in case of context integration invoke the application service.

  Here is the origin the JMSMessageReceiver located in the infrastructure layer. The MessageReceiver is also responsible for Event de-duplication. This can happen in case of system failure, when already delivered Events are redelivered or something else went wrong. Since the Infrastructure Layer is located above the Application Layer, it can invoke the CustomerApplicationService, which itself calls the CustomerService, which implements the business logic to send a bill.

  In this scenario, the transaction boundaries are at the ApplicationService. We can argue that the JMSMessageReceiver might call the CustomerService, and do it around a JMSTransaction. This is also a viable solution.

  The tricky part is Event de-duplication. This can happen in case of infrastructure failure or system outage. This can be avoided by giving every Event an unique id, and track which ids were already processed.

  Another tricky part is Event ordering. This depends on the messaging infrastructure. If the infrastructure supports Event ordering, everything is alright. If not, this must be implemented by ourselves. In any case it is a good practice to design Events as an idempotent operation. This means that every Event can be processed multiple times, and every time with the same result without unwanted side effects.

  Query data from multiple Bounded Contexts or Aggregates
  Sometimes we need to collect data spread over multiple Aggregates or even Bounded Contexts. This can be a tough task. Within one Bounded Context we could use specialized database views and retrieve data using Hibernate or JPA, but getting data spread over multiple Bounded Contexts can lead to a lot of remote method invocations and other issues; this solution might not scale well. We have also to consider that using a view might break the business invariance of a well designed Aggregate. This is an issue we really have to take care of!

  Now, what might be a solution? We can think about CQRS or Command-Query Responsibility Segregation! Basically we divide the model into a command model, which contains business logic, and a query model, which is used to retrieve data. So for this example, the command model would consist of all the Bounded Contexts we want to query, and a query model, which is used to query aggregated data(and is optimized to query data effectively). The command model and query model are synchronized using Domain Events! Once a business operation is triggered in the command model, a Domain Event is issued and processed by the Query Model, and the data is updated.

  Using CQRS, we can design high performance data processing systems and also integrating with Business Intelligence is no problem anymore. Think about it: the query model can basically be a data warehouse.

  Final words
  I really like the idea behind Domain-driven Design. Using this technique, even very complex domain logic can be easily distilled and modeled. This leads to better systems, improved user experience and also more reliable and maintainable solutions. Thanks to Eric Evans and Vaughn Vernon! DDD / Domain-driven Design is object oriented programming done right.


%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section{"data-markdown" => ""}
  \##### Adaptive Systeme
  \### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Ändern sich die Systemanforderungen zur Laufzeit, kann das Microkernel Muster angewendet werden.

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Aufgaben
  * Der Mikrokernel bietet die Basis für mögliche Erweiterungen
  * Der Microkernel koordiniert die Zusammenarbeit.

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Herausforderung

  \#### Damit nicht nur die heutige Technik integriert werden kann, muss das System auch zukünftigen Hard- und Software-Entwicklungen standhalten

%section{"data-markdown" => ""}
  \#### Mikrokernel

  Beispiel: Linux Kernel

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Vorteile

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Nachteile

%section{"data-markdown" => ""}
  \##### Adaptive Systeme
  \#### Mikrokernel
  \### Reflexion
  \### Dependency Injection


%section{"data-markdown" => ""}
  \### Fragen?

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \### Domain-spezifische Architektur

%section{"data-markdown" => ""}
  \### Domain-spezifische Architektur

  * Telekommunikation
  * Avionik
  * Automotive

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \## Fragen?

  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
