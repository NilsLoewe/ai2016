---
title: Vorlesung 7 - Architekturmuster
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule für angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils Löwe / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \## 3. Praktikum
  [Praktikum 3: Architekturentwurf](https://ai2016.nils-loewe.de/p03.html)
  \### Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Wiederholung
  \### Architekturmuster

%section
  %h4
    Ein Architekturmuster beschreibt eine bewährte Lösung für ein wiederholt auftretendes Entwurfsproblem
  %p
    %i (Effektive Softwarearchitekturen)

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \### Domain-driven Design

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design ist nicht nur eine Technik oder Methode. Es ist viel mehr eine Denkweise und
    Priorisierung zur Steigerung der Produktivität von Softwareprojekten im Umfeld komplexer fachlicher
    Zusammenhänge

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design basiert auf folgenden zwei Annahmen:
  %ul
    %li Der Schwerpunkt des Softwaredesigns liegt auf der Fachlichkeit und der Fachlogik.
    %li Der Entwurf komplexer fachlicher Zusammenhänge sollte auf einem Modell der Anwendungsdomäne, dem Domänenmodell basieren.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Bestandteile des Domänenmodells
  %p Domain-driven Design unterscheidet die folgenden Bestandteile des Domänenmodells:
  %br
  ![](/images/DomainDrivenDesign_map.png)

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \### Architekturtechniken
  \#### Evolvierende Struktur (evolving order)
  \#### Systemmetapher (system metaphor)
  \#### Verantwortlichkeitsschichten (responsibility layers)
  \#### Wissenslevel (knowledge level)
  \#### Erweiterungsframeworks (pluggable component framework)

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### "SOA ist ein Paradigma für die Strukturierung und Nutzung verteilter Funktionalität, die von unterschiedlichen Besitzern verantwortet wird."

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * SOA soll Dienste von IT-Systemen strukturieren und zugänglich machen.
  * SOA orientiert sich an Geschäftsprozessen
  * Geschäftsprozesse sind die Grundlage für konkrete Serviceimplementierungen

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \#### Beispiel für einen Geschäftsprozess: **„Vergib einen Kredit“**

  * Auf einer hohen Ebene angesiedelt
  * Zusammengesetzt aus
  * _„Eröffnen der Geschäftsbeziehung“_
  * _„Eröffnen eines oder mehrerer Konten“_
  * _„Kreditvertrag“_

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * Ein Dienst ist eine IT-Repräsentation von fachlicher Funktionalität.
  * Ein Dienst ist in sich abgeschlossen (autark) und kann eigenständig genutzt werden.
  * Ein Dienst ist in einem Netzwerk verfügbar.
  * Ein Dienst hat eine wohldefinierte veröffentlichte Schnittstelle (Vertrag). Für die Nutzung reicht es, die Schnittstelle zu kennen. Kenntnisse über die Details der Implementierung sind hingegen nicht erforderlich.

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Vorteile
  * Eine agile IT-Umgebung, die schnell auf geschäftliche Veränderungen reagieren kann
  * Niedrigere Gesamtbetriebskosten durch die Wiederverwendung von Services
  * Höhere Leistung, größere Skalierbarkeit und Transparenz
  * Dienstleistungen und Produkte können schneller auf den Markt gebracht werden

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Nachteile
  * SOA wird von Marketingabteilungen gehyped: Einführung von SOA ist die Lösung aller bisherigen Probleme
  * SOA generiert einen höheren Aufwand als bisherige monolithische Programmstrukturen.
  * SOA erzeugt im Code wesentlich komplexere Abläufe
  * SOA setzt für die beteiligten Entwickler ein erhebliches Know-how voraus.
  * _Somit sind Entwickler auch nicht so einfach ersetzbar, und die Abhängigkeit der Unternehmen von einzelnen Entwicklern steigt deutlich._

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### In einem reinen Peer-to-Peer-Netz sind alle Computer gleichberechtigt und können sowohl Dienste in Anspruch nehmen, als auch zur Verfügung stellen.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer
  ![](/images/PeerToPeer.jpg)

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \#### Typische Eigenschaften:

  * Hohe Heterogenität bezüglich der Bandbreite, Rechenkraft, Online-Zeit
  * Die Verfügbarkeit und Verbindungsqualität der Peers kann nicht vorausgesetzt werden
  * Peers bieten Dienste und Ressourcen an und nehmen Dienste anderer Peers in Anspruch
  * Dienste und Ressourcen können zwischen allen teilnehmenden Peers ausgetauscht werden.
  * Peers haben eine signifikante Autonomie (über die Ressourcenbereitstellung).
  * Das P2P-System ist selbstorganisierend.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Vorteile
  * alle Computer sind gleichberechtigt
  * Kostengünstiger als Servernetzwerke
  * Kein leistungsstarker zentraler Server erforderlich
  * Keine spezielle Netzwerksoftware erforderlich
  * Benutzer verwalten sich selbst
  * Keine hierarchische Netzwerkstruktur

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Nachteile
  * Zentrale Sicherheitsaspekte sind nicht von Bedeutung
  * Sehr schwer zu administrieren
  * kein einziges Glied im System ist verlässlich

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \### Client-Server

%section{"data-markdown" => ""}
  \#### Client-Server

  \### Das Client-Server-Modell verteilt Aufgaben und Dienstleistungen innerhalb eines Netzwerkes.

%section{"data-markdown" => ""}
  \#### Client-Server

  * Der Client kann auf Wunsch einen Dienst vom Server anfordern
  * Der Server beantwortet die Anforderung.
  * Üblicherweise kann ein Server gleichzeitig für mehrere Clients arbeiten.

%section{"data-markdown" => ""}
  \#### Client-Server
  ![](/images/client-server.jpg)

%section{"data-markdown" => ""}
  \#### Client-Server

  * Clients und Server können als Programme auf verschiedenen Rechnern oder auf demselben Rechner ablaufen.
  * Das Konzept kann zu einer Gruppe von Servern ausgebaut werden, die eine Gruppe von Diensten anbietet.
  * In der Praxis laufen Server-Dienste meist gesammelt auf bestimmten Rechnern, die dann selber "Server" genannt werden

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Vorteile
  * Gute Skalierbarkeit
  * Einheitliches Auffinden von Objekten

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Nachteile
  * Der Server muss immer in Betrieb sein
  * Der Server muss gegen Ausfall und Datenverlust gesichert werden

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  Das MVC-Pattern ist eine spezielle Variante des Layers-Pattern, die sich aus den
  drei Schichten Datenhaltung (Model), Programmlogik (Controller) und Präsentation (View) zusammensetzt.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  * Model: Speicherung und Zugriffskontrolle von Daten
  * View: Darstellung der Daten für die Anwender
  * Controller: Vermittlung zwischen View und Model

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  ![](/images/mvc.png)


%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Model

  * Das Modell kapselt Kerndaten und Funktionalität.
  * Das Modell ist unabhängig von einer bestimmten Darstellung der Ausgabe oder einem bestimmten Verhalten der Eingabe.
  * Das Modell bildet die Kernfunktionalität der Anwendung ab.
  * (Das Modell benachrichtigt registrierte bei Datenänderungen.)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: View

  * Die Sicht (view) zeigt dem Benutzer Informationen an.
  * Es kann mehrere Sichten pro Modell geben.
  * Ggf. zugeordnete Eingabeelemente anzeigen

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Controller

  * Der Controller verarbeitet Eingaben und ruft passende Dienste der zugeordeten Sicht oder des Modells auf.
  * Jede Controller ist einer Sicht zugeordnet
  * Es kann mehrere Controller pro Modell geben.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Vorteile

  * Mehrere Sichten desselben Modells
  * Automatische Synchronisation aller Views
  * Austauschbarkeit von Views und Controllern
  * Gute Trennung von Modell und View
  * Potential für vorgefertigte Frameworks

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Nachteile
  * Erhöhte Komplexität
  * Starke Kopplung zwischen Modell und View
  * Starke Kopplung zwischen Modell und Controller
  * Potential für unnötig häufige Aktualisierungen
  * Häufig ineffizienter Datenzugriff auf das Modell.
  * View und Controller sind schwer zu portieren.

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Presenter

  \### Hervorgegangen aus dem Model-View-Controller (MVC) Architekturmuster.

  Vollständige Trennung von Model und View, Verbindung über einen Presenter.

%section{"data-markdown" => ""}
  \#### Model View Presenter

  * Vollständige Trennung von Model und View
  * Deutlich verbesserte Testbarkeit
  * Strenge Trennung der einzelnen Komponenten

%section{"data-markdown" => ""}
  \#### Model View Presenter (MVP)
  ![](/images/mvp.png)

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hohe Flexibilität für ein System, das aus vielen autarken Einzelsystemen zusammengesetzt ist.

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  * Große Systeme, für die das Model-View-Controller-Muster nicht ausreicht
  * Aufteilung des Systems in zwei Richtungen
  * --> In die drei Einheiten Presentation, Control und Abstraction (ähnlich dem MVC)
  * --> Hierarchisch in verschiedene Teile („Agenten“), die jeweils einen Teil der Aufgaben des Systems anbieten

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Agenten

  * Stellen die erste Stufe der Strukturierung während des Architekturentwurfes dar
  * Aufteilung der gesamten Anforderungen auf einzelne Agenten
  * Aufbau der hierarchischen Struktur
  * Für jeden Agenten erfolgt dann eine Aufteilung in Presentation, Abstraction und Control

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hierarchie: Drei Schichten

  * Top-Level-Agent: Globale Aufgaben
  * Intermediate-Level-Agenten: Strukturierung der Bottom-Level-Agenten
  * Bottom-Level-Agenten: Konkrete, abgeschlossene Aufgaben

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Aufteilung der Agenten

  * Nicht jeder Agent muss alle drei Komponenten implementieren
  * Jeder Agent bringt die Benutzerschnittstelle und das Datenmodell für seine Aufgabe mit
  * Jeder Agent muss die Control implementieren, um über sie die Kommunikation mit anderen Agenten und zwischen den Komponenten zu ermöglichen

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Vorteile
  * Zerlegung der Funktionen des Gesamtsystems in einzelne semantisch getrennte Teile
  * Gute Erweiterbarkeit durch neue Agenten
  * Gute Wartbarkeit ist durch die interne Struktur der Agenten

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Nachteile
  * Erhöhte Systemkomplexität
  * Erhöhter Koordinations- und Kommunikationsaufwand zwischen den Agenten
  * Die Steuerungskomponenten können eine hohe Komplexität erreichen

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \### Adaptive Systeme

%section{"data-markdown" => ""}
  \##### Adaptive Systeme
  \### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Ziel: Änderung von Systemanforderungen zur Laufzeit dynamisch begegnen.

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Aufgaben
  * Der Mikrokernel bietet die Basis für mögliche Erweiterungen
  * Der Microkernel koordiniert die Zusammenarbeit.

%section{"data-markdown" => ""}
  \#### Microkernel
  \### Herausforderung

  ![](/images/microkernel.png)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Microkernel

  * Minix Kernel
  * GNU Mach
  * AmigaOS
  * SymbianOS

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Monolithische Kernels

  * Linux
  * Android
  * Windows bis Win98 (DOS Kernel)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Hybrid-Kernels

  * MacOS X (Darwin)
  * Windows NT (oft als Microkernel bezeichnet)


%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Vorteile

  * Separierte Komponenten: Austauschbarkeit
  * Treiber im Benutzer-Modus: Sicherheit
  * kleine Trusted Computing Base
  * Skalierbarkeit
  * Zuverlässigkeit
  * Transparenz

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Nachteile

  * Leistung
  * Komplexität

%section{"data-markdown" => ""}
  \### Fragen?

%section{"data-markdown" => ""}
  \### Domain Driven Design
  \## Ein Beispiel

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Eine Firma bietet Softwareentwicklung als Dienstleistung an.

  \###### http://blog.mirkosertic.de/architecturedesign/dddexample

  * Aufwand wird nach Stunden verrechnet
  * Es gibt festangestellte Softwareentwickler
  * Es gibt einen Pool von Freelancern.
  * Bisher wird die Zuordnung von Entwicklern zu Projekten in einem Excel-Sheet organisiert


%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Probleme mit dem Excel-Ansatz

  * Excel skaliert nicht auf mehrere Anwender
  * Keine Sicherheit
  * Kein Logging

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel
  \### Lösung: Neue Software bauen

  * Durchsuchbarer Katalog von Freelancern
  * Mehrere Kontaktmöglichkeiten pro Freelancer
  * Durchsuchbarer Katalog von Projekten
  * Durchsuchbarer Katalog von Projekten
  * Timesheets für jeden Freelancer (pro Projekt)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddfirstrun.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Straight forward Ansatz
  * Kunden
  * Freelancer
  * Projekte
  * Timesheets
  * User Management: Rolle

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz
  \### Probleme?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Großer Objektgraph: Performance Probleme unter Last
  Framework wie Hibernate wäre notwendig um das zu vermeiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Warum die bidirektionale Verknüpfung zwischen User und Rolle?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Boolean-Flags um den Kontakttypen zu unterscheiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Projekt-Liste in der Freelancer-Klasse:
  \#### Freelancer verändern um Projekte zuzufügen
  Potentielle Transaktionsprobleme unter Last (mehrere Leute legen gleichzeitig Projekte für den gleichen Kunden an)

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  * Kontaktinformation == Kommunikationskanal?
  * Das Diagramm ist eher ein Entiy-Relationship-Diagram als ein Software Modell
  * Wo ist die Businesslogik?

%section{"data-markdown" => ""}
  \### DDD nutzen

  * Gemeinsame Sprache schaffen um zwischen Entwicklern und Domänenexperten zu vermitteln
  * Komplexität reduzieren durch OO-Design Prinzipien

%section{"data-markdown" => ""}
  \#### DDD nutzen
  \#### Anforderungen: "Body Leasing Domain"
  \### **Context-Map: Komplexität reduzieren durch Subdomains**

  * Identität und Access Management Subdomain
  * Freelancer Management Subdomain
  * Kundenmanagement Subdomain
  * Projektmanagement Subdomain

%section{"data-markdown" => ""}
  \#### DDD - Context Map
  ![](/images/dddcontextmap.png)

%section{"data-markdown" => ""}
  \#### DDD - Bounded Context

  * Zuordnen von Subdomains zu Teilen der Lösung
  * *Building blocks* nutzen (Design Pattern anwenden)
  * Die DDD Architekturpattern sind nicht technologieabhängig!

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddrevised.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Bounded Contexts für jede Subdomain
  * Bounded Contexts sind isoliert und unabhängig
  * Verbindungen durch common types (UserId, ProjectId, CustomerId): “Generic Subdomain”

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Jeder Bounded Context enthält Aggregates und Wertobjekte
  * Aggregates sind Objekthierarchien
  * Nur das Root-Objekt eines Aggregates ist von außen zugreifbar
  * Jeder Zugriff auf ein Objekt passiert durch die Aggregates: Bessere Kapselung
  * Aggregates und Entites besitzen eine ID
  * Wertobjekte haben keine ID und können ihren Zustand nicht ändern
  * Jede Zustandsänderung erzeugt ein neues Wertobjekt: Vermeiden von Seiteneffekten

%section{"data-markdown" => ""}
  \#### DDD - Beschreibung von Verhalten

  \### Use Case: “Freelancer zieht um”

%section{"data-markdown" => ""}
  \#### Entwurf ohne DDD

  ![](/images/dddbehavior.png)

%section{"data-markdown" => ""}
  \#### DDD - Probleme

  * Name etc. ändern durch Setter-Methoden
  * Setter können von diversen Orten aufgerufen werden
  * Rollenbasierte Security schwer umsetzbar
  * Kein Kontext des Aufrufers bekannt
  * Kein "Adress-Konzept", lediglich einzelne Felder

%section{"data-markdown" => ""}
  \#### Entwurf mit DDD

  ![](/images/dddbehaviorrevised.png)

%section{"data-markdown" => ""}
  \#### DDD Ansatz - Vorteile

  * Der Freelancer hat nur ein Attribut: Die Adresse
  * Eine Adresse ist immutable, Änderungen erzeugen neue Adress-Objekte
  * getAdress gibt ein immutable Adress-Objekt zurück
  * movedTo(Adress) bildet explizit den UseCase ab
  * Rollenbasierte Security ist möglich

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Persistenz in DDD wird mit "Repositories" umgesetet
  * Ein Repository ist durchsuchbar, kann Instanzen liefern und löschen, sowie neue Instanzen ablegen
  * Es sollte ein Repository für jedes Aggregate geben

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddusecasepersistence.png)

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Ein Client ist ein abstraktes Konzept
  * Ein Client kann alles von einem Frontend über einen SOAP Webservice zu einer REST Ressource sein
  * Ein Client sendet Befehle an den ApplciationService

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Der ApplicationService setzt die Befehle in UseCases um
  * Der FreelancerApplicationService lädt dasFreelancer Aggregate aus dem FreelancerRepository und ruft moveTo() auf dem FreelancerAggregate auf
  * Der FreelancerApplicationService bildet dabei die Transactionsgrenzen.
  * Jeder Aufruf erzeugt eine neue Transaktion

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  * Jeder Bounded Context sollte eine "Deployment Unit" bilden, z.B. ein Java WAR file oder ein EJB JAR
  * Die Bounded Contexts sind unabhängig designt, sie sollten daher auch unabhängig implementiert werden

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  \### Jede Deployment Unit enthält die folgenden Elemente:

  * Domain Layer: Domänenlogik
  * Infrastructure Layer: Technologieabhängige Artefakte (z.B. Hibernate für Repository)
  * Application Layer: Gateway zur Businesslogik mit Transaktionskontrolle

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer1.png)

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer2.png)

%section{"data-markdown" => ""}
  \#### DDD - Vorteile

  * Der Domain Layer basiert nicht auf anderen Teilen der Architektur
  * Die Repository Implementierung kann getauscht werden, ohne die Businesslogik zu beeinflusseng any business logic.

%section{"data-markdown" => ""}
  \#### DDD -  Domain Layer

  * Enthält die Businesslogik, keine Abhängigkeiten der Infrastruktur
  * Die Modelle sollten nach dem CQS(Command-Query-Separation) Prinzip entworfen werden
  * --> Query Methoden geben lediglich Daten zurück ohne Zustände zu ändern
  * --> Command Methoden ändern den Stade

%section{"data-markdown" => ""}
  \#### DDD - Application Layer

  * Der Application Layer nimmt Kommandos des User Interface Layer an
  * Der Application Layer ruft UseCase Implementierungen im Domain layer auf
  * Der Application Layer biete Transactioskontrolle für Business Operationen

%section{"data-markdown" => ""}
  \#### DDD - Infrastructure Layer

  Der Infrastructure Layer bietet Infrastrukturabhängige Teile für alle anderen Layer


%section{"data-markdown" => ""}
  \#### DDD - User Interface Layer

  * Der User Interface Layer konsumiert Application Services und ruft Funktionalität der Businesslogik auf diesen Services auf.
  * Jeder Aufruf ist eine neue Transaktion
  * Der User Interface Layer kann beliebig implementiert sein, z.B. ein SOAP webservice, eine REST Resource oder eine Swing/AWT GUI

%section{"data-markdown" => ""}
  \#### DDD - Context Integration

  \### Anforderungen:
  * Ein Kunde kann nur gelöscht werden, wenn er keinem aktiven Projekt zugeordnet ist
  * Wenn ein Timesheet erstellt wurde, muss eine Rechnung erstellt werden

%section{"data-markdown" => ""}
  \#### DDD - Context Integration

  * *Customer Management Bounded Context* prüft ob ein Projekt für den übergebenen Kunden existiert, bevor der Kunde gelöscht werden kann.
  * Ziel: *Bounded Contexts* sollen unabhängig bleiben

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (synchron)

  ![](/images/dddsyncexample1.png)

%section{"data-markdown" => ""}
  \#### DDD - *Domain Service*

  * Ein *Domain Service* implementiert Business Logik, die nicht durch eine Entity, Aggragate oder ValueObject implementiert werden kann.
  * Z.B. wenn Business Logik Operationen betreffen mehrere *Domain Objects* oder Interaktionen mit anderen *Bounded Contexts*

  * *ApplicationService* ruft *deleteCustomerById* des *CustomerService* auf
  * *CustomerService* ruft *ProjectManagementAdapter* durch *customerExists()* auf
  * Ein Kunde wird nur aus dem CustomerRepository gelöscht, wenn *customerExists()* false zurückgibt.

%section{"data-markdown" => ""}
  \#### DDD - *Domain Service*

  * Es existieren zwei Implementierungen des *ProjectManagementAdapter*, basierend auf SOAP und REST
  * Die Implementierung kann leicht verändert werden ohne den DomainLayer zu beeinflussen

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (synchron)

  ![](/images/dddsyncexample2.png)

%section{"data-markdown" => ""}
  \#### DDD - Transaktionsgrenzen

  * WebService oder REST Ressourcen bieten keine automatischen Transaktionen
  * XA/two-phase-commit erhöht die Komplexität und rediziert die Skalierbarkeit
  * Besser wäre es, Kunden nicht zu löschen, sondern als logisch gelöscht zu markieren
  * --> Bei Transaktionsfehlern lässt sich der originale Zustand wiederherstellen

%section{"data-markdown" => ""}
  \#### DDD - Ein komplexeres Beispiel

  \### Wenn ein Timesheet abgegeben wurde, soll eine Rechnung erstellt werden

  * Synchronität ist nicht notwendig: Die Rechnung kann auch Stunden später oder am Monatsende erstellt werden.
  * Die Rechnung kann in einem anderen System weiterverarbeitet werden, das nicht Teil unseres Systems ist

%section{"data-markdown" => ""}
  \#### DDD - Ein komplexeres Beispiel

  \#### "Wenn ein Timesheet abgegeben wurde..." ist ein Business-Event

  * Domain Events werden erzeugt und im Event Store gespeichert und von dort weiterverarbeitet
  * Der Event Store ist Teil des Bounded Context
  * Das Bearbeiten von Domain-Events in einer Transaktion ist ist Aufgabe des ApplicationService
  * Auf Seite der Infrastruktur werden gespeicherte Events mit einer Messaging Technologie wie JMS oder AMQP ausgeliefert

%section{"data-markdown" => ""}
  \#### DDD - Wozu ein lokaler Eventstore?

  * Die Messaging Infrastruktur könnte ausgefallen sein
  * Der Bounded Context sollte nicht abhängig von Infrastrukturproblemen sein
  * --> Events werden gespeichert bis die Infrastruktur wieder verfügbar ist
  * Messaging vermeidet unnötig enge Kopplung von Systemen

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (asynchron)

  ![](/images/dddasyncexample1.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  * Der *FreelancerService* erzeugt ein *TimesheetEntered*  Domain-Event
  * Das Event wird zum *EventStore* weitergeleitet
  * Der *JMSMessagingAdapter* nimmt Events aus dem EventStore und leitet sie an die Messaging-Infrastruktur weiter

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (asynchron)

  ![](/images/dddasyncexample2.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (asynchron)

  * Auch hier muss der Infrastruktur-Layer global verfügbar sein
  * Der *JMSMessageReceiver* liegt im Infrastruktur-Layer
  * Der *CustomerApplicationService* benutzt den *CustomerService*
  * Die Transaktionsgrenzen sind der *ApplicationService*

%section{"data-markdown" => ""}
  \#### DDD - Event de-duplication

  * Bei Infrastruktur-Problemen können Events doppelt versendet werden
  * Lösung: Eindeutige ID für Events + Tracking der verarbeiteten Events

%section{"data-markdown" => ""}
  \#### DDD - Zusammenfassung

  * Auch sehr komplexe Domänenlogik kann relativ einfach modelliert werden
  * Die Systeme werden besser entkoppelt und wartbar

%section{"data-markdown" => ""}
  \#### DDD - Zusammenfassung

  \### Domain-driven Design is object oriented programming done right. *(Eric Evans)*

%section{"data-markdown" => ""}
  \### Rückblick auf Architekturmuster

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section
  %h3 Chaos zu Struktur / Mud-to-structure
  %ul
    %li Organisation der Komponenten und Objekte eines Softwaresystems
    %li Die Funktionalität des Gesamtsystems wird in kooperierende Subsysteme aufgeteilt
    %li Zu Beginn des Softwareentwurfs werden Anforderungen analysiert und spezifiziert
    %li Integrierbarkeit, Wartbarkeit, Änderbarkeit, Portierbarkeit und Skalierbarkeit sollen berücksichtigt werden

%section{"data-markdown" => ""}
  \### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h3 Verteilte Systeme
  %ul
    %li Verteilung von Ressourcen und Dienste in Netzwerken
    %li Kein "zentrales System" mehr
    %li Basiert auf guter Infrastruktur lokaler Datennetze

%section{"data-markdown" => ""}
  \### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section
  %h3 Interaktive Systeme
  %ul
    %li Strukturierung von Mensch-Computer-Interaktionen
    %li Möglichst gute Schnittstellen für die Benutzer schaffen
    %li Der eigentliche Systemkern bleibt von der Benutzerschnittstelle unangetastet.

%section{"data-markdown" => ""}
  \### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section
  %h3 Adaptive Systeme
  %ul
    %li Unterstützung der Erweiterungs- und Anpassungsfähigkeit von Softwaresystemen.
    %li Das System sollte von vornherein mögliche Erweiterungen unterstützen
    %li Die Kernfunktionalität sollte davon unberührt bleiben kann.

%section{"data-markdown" => ""}
  \### Adaptive Systeme
  \#### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \### Wie wähle ich denn nun das passende Muster aus?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### Nutzen von Templates

  Beispiele:
  * arc42
  * Normen
  * Software Guidebook

%section{"data-markdown" => ""}
  \### ARC42
  \#### (Dr. Gernot Starke / Dr. Peter Hruschka)
  http://www.arc42.de/

  \#### *arc42 unterstützt Software- und Systemarchitekten. Es kommt aus der Praxis und basiert auf Erfahrungen internationaler Architekturprojekte und Rückmeldungen vieler Anwender.*

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### ARC42

  1. Einführung und Ziele
  2. Randbedingungen
  3. Kontextabgrenzung
  4. Lösungsstrategie
  5. Bausteinsicht
  6. Laufzeitsicht
  7. Verteilungssicht
  8. Querschnittliche Konzepte/Muster
  9. Entwurfsentscheidungen
  10. Qualitätsszenarien
  11. Risiken
  12. Glossar

%section{"data-markdown" => ""}
  \#### ARC42
  ![](/images/arc42.png)

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 1. Einführung und Ziele
  * Aufgabenstellung
  * Qualitätsziele
  * eine Kurzfassung der architekturrelevanten Anforderungen (insb. die nichtfunktionalen)
  * Stakeholder

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 2. Randbedingungen
  Welche Leitplanken schränken die Entwurfsentscheidungen ein?
  * Technische Randbedingungen
  * Organisatorische Randbedingungen
  * Konventionen

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 3. Kontextabgrenzung
  * Fachlicher Kontext
  * Technischer- oder Verteilungskontext

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 4. Lösungsstrategie
  Wie funktioniert die Lösung? Was sind die fundamentalen Lösungsansätze?

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 5. Bausteinsicht
  Die statische Struktur des Systems, der Aufbau aus Implementierungsteilen.

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 6. Laufzeitsicht
  Zusammenwirken der Bausteine zur Laufzeit, gezeigt an exemplarischen Abläufen ("Szenarien")

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 7. Verteilungssicht
  Deployment: Auf welcher Hardware werden die Bausteine betrieben?

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 8. Querschnittliche Konzepte und Muster
  * Wiederkehrende Muster und Strukturen
  * Fachliche Strukturen
  * Querschnittliche, übergreifende Konzepte
  * Nutzungs- oder Einsatzanleitungen für Technologien
  * Oftmals projekt-/systemübergreifend verwendbar!

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 9. Entwurfsentscheidungen
  ![](/images/entscheidung.png)

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 10. Qualitätsszenarien
  Qualitätsbaum sowie dessen Konkretisierung durch Szenarien

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 11. Risiken

  Eine nach Prioritäten geordnete Liste der erkannten Risiken

  \#### "Risikomanagement ist Projektmanagement für Erwachsene"

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 12. Glossar
  Die wichtigsten Begriffe der Software-Architektur in alphabetischer Reihenfolge

%section{"data-markdown" => ""}
  \#### ARC42
  http://confluence.arc42.org/
  \## Fragen?

%section{"data-markdown" => ""}
  \### IEEE Standards

  **IEEE Standards** documents are developed within the IEEE Societies and the Standards Coordinating Committees of
  the IEEE Standards Association (IEEE-SA) Standards Board. The IEEE develops its standards through a consensus
  development process, approved by the American National Standards Institute, which brings together volunteers representing
  varied viewpoints and interests to achieve the final product. Volunteers are not necessarily members of the
  Institute and serve without compensation. While the IEEE administers the process and establishes rules to promote
  fairness in the consensus development process, the IEEE does not independently evaluate, test, or verify the accuracy
  of any of the information contained in its standards or implementations thereof.

%section{"data-markdown" => ""}
  \### IEEE Standards

  * IEEE 802:    LAN
  * IEEE 802.3:  Carrier sense multiple access with collision detection (CSMA/CD)
  * IEEE 802.11: Wireless LAN
  * IEEE 830:    Recommended Practice for Software Requirements Specifications
  * IEEE 1394:   FireWire/i.Link Bussysteme
  * IEEE 1471:   Recommended Practice for Architectural Description of Software-Intensive Systems
  * IEEE 9945:   Portable Operating System Interface (POSIX®)

%section{"data-markdown" => ""}
  \### IEEE 830-1998

%section{"data-markdown" => ""}
  \#### IEEE
  \## Fragen?

%section{"data-markdown" => ""}
  \### Software Guidebook

  * Template von Simon Brown aus dem Buch *"Software Architecture for Developers"*
  * Buch: https://leanpub.com/software-architecture-for-developers
  * Beispiel: https://leanpub.com/techtribesje (kostenlos)

%section{"data-markdown" => ""}
  \### Software Guidebook

  \#### Welche Informationen wünsche ich mir, wenn ich in ein neues Projekt komme?

  * Karten
  * Sichten
  * Geschichte
  * Praktische Informationen!

%section{"data-markdown" => ""}
  \### Software Guidebook
  \## Product vs project documentation

%section{"data-markdown" => ""}
  \### Software Guidebook
  1.  Context
  2. Functional Overview
  3. Quality Attributes
  4. Constraints
  5. Principles
  6. Software Architecture
  7. External Interfaces
  8. Code
  9. Data
  10. Infrastructure Architecture
  11. Deployment
  12. Operation and Support
  13. Development Environment


%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Context
  A context section should be one of the first sections of the software guidebook and simply
  used to set the scene for the remainder of the document.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Context
  A context section should answer the following types of questions:
  * What is this software project/product/system all about?
  * What is it that’s being built?
  * How does it fit into the existing environment? (e.g. systems, business processes, etc)
  * Who is using it? (users, roles, actors, personas, etc)

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Functional Overview
  Even though the purpose of a software guidebook isn’t to explain what the software does in
  detail, it can be useful to expand on the context and summarise what the major functions of
  the software are.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Functional Overview
  * Is it clear what the system actually does?
  * Is it clear which features, functions, use cases, user stories, etc are significant to the
  architecture and why?
  * Is it clear who the important users are (roles, actors, personas, etc) and how the system
  caters for their needs?
  * It is clear that the above has been used to shape and define the architecture?
  Alternatively, if your software automates a business process or workflow, a functional view
  should answer questions like the following:
  * Is it clear what the system does from a process perspective?
  * What are the major processes and flows of information through the system?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Quality Attributes
  With the functional overview section summarising the functionality, it’s also worth including
  a separate section to summarise the quality attributes/non-functional requirements.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Quality Attributes
  * Is there a clear understanding of the quality attributes that the architecture must satisfy?
  * Are the quality attributes SMART (specific, measurable, achievable, relevant and timely)?
  * Have quality attributes that are usually taken for granted been explicitly marked as out of scope if they are not needed? (e.g. “user interface elements will only be presented in English” to indicate that multi-language support is not explicitly catered for)
  * Are any of the quality attributes unrealistic? (e.g. true 24x7 availability is typically very costly to implement inside many organisations)

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Quality Attributes
  Simply listing out each of the quality attributes is a good starting point. Examples include:
  * Performance (e.g. latency and throughput)
  * Scalability (e.g. data and traffic volumes)
  * Availability (e.g. uptime, downtime, scheduled maintenance, 24x7, 99.9%, etc)
  * Security (e.g. authentication, authorisation, data confidentiality, etc)
  * Extensibility
  * Flexibility
  * Auditing

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Quality Attributes
  * Monitoring and management
  * Reliability
  * Failover/disaster recovery targets (e.g. manual vs automatic, how long will this take?)
  * Business continuity
  * Interoperability
  * Legal, compliance and regulatory requirements (e.g. data protection act)
  * Internationalisation (i18n) and localisation (L10n)
  * Accessibility
  * Usability

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Constraints
  Software lives within the context of the real-world, and the real-world has constraints. This
  section allows you to state these constraints so it’s clear that you are working within them
  and obvious how they affect your architecture decisions.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Constraints
  Constraints are typically imposed upon you but they aren’t necessarily “bad”, as reducing
  the number of available options often makes your job designing software easier. This section
  allows you to explicitly summarise the constraints that you’re working within and the
  decisions that have already been made for you.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Constraints
  * Time, budget and resources.
  * Approved technology lists and technology constraints.
  * Target deployment platform.
  * Existing systems and integration standards.
  * Local standards (e.g. development, coding, etc).
  * Public standards (e.g. HTTP, SOAP, XML, XML Schema, WSDL, etc).
  * Standard protocols.
  * Standard message formats.
  * Size of the software development team.
  * Skill profile of the software development team.
  * Nature of the software being built (e.g. tactical or strategic).
  * Political constraints.
  * Use of internal intellectual property.
  * etc

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Principles
  The principles section allows you to summarise those principles that have been used (or you
  are using) to design and build the software.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Principles
  The purpose of this section is to simply make it explicit which principles you are following.
  These could have been explicitly asked for by a stakeholder or they could be principles that
  you (i.e. the software development team) want to adopt and follow.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Principles
  If you have an existing set of software development principles (e.g. on a development wiki),
  by all means simply reference it. Otherwise, list out the principles that you are following and
  accompany each with a short explanation or link to further information.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Principles
  Example principles include:
  * Architectural layering strategy.
  * No business logic in views.
  * No database access in views.
  * Use of interfaces.
  * Always use an ORM.
  * Dependency injection.
  * The Hollywood principle (don’t call us, we’ll call you).
  * High cohesion, low coupling.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Principles
  * Follow SOLID (Single responsibility principle, Open/closed principle, Liskov substitution principle, Interface segregation principle, Dependency inversion principle).
  * DRY (don’t repeat yourself).
  * Ensure all components are stateless (e.g. to ease scaling).
  * Prefer a rich domain model.
  * Prefer an anaemic domain model.
  * Always prefer stored procedures.
  * Never use stored procedures.
  * Don’t reinvent the wheel.
  * Common approaches for error handling, logging, etc.
  * Buy rather than build.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Software Architecture
  The software architecture section is your “big picture” view and allows you to present the
  structure of the software. Traditional software architecture documents typically refer to this
  as a “conceptual view” or “logical view”, and there is often confusion about whether such
  views should refer to implementation details such as technology choices.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Software Architecture
  * What does the “big picture” look like?
  * Is there are clear structure?
  * Is it clear how the system works from the “30,000 foot view”?
  * Does it show the major containers and technology choices?
  * Does it show the major components and their interactions?
  * What are the key internal interfaces? (e.g. a web service between your web and business tiers)

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### External Interfaces
  Interfaces, particularly those that are external to your software system, are one of the riskiest
  parts of any software system so it’s very useful to summarise what the interfaces are and how
  they work.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### External Interfaces
  * What are the key external interfaces?
  * e.g. between your system and other systems (whether they are internal or external to your environment)
  * e.g. any APIs that you are exposing for consumption
  * e.g. any files that your are exporting from your system
  * Has each interface been thought about from a technical perspective?
  * What is the technical definition of the interface?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### External Interfaces
  * If messaging is being used, which queues (point-to-point) and topics (pub-sub) are components using to communicate?
  * What format are the messages (e.g. plain text or XML defined by a DTD/ Schema)?
  * Are they synchronous or asynchronous?
  * Are asynchronous messaging links guaranteed?
  * Are subscribers durable where necessary?
  * Can messages be received out of order and is this a problem?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### External Interfaces
  * Are interfaces idempotent?
  * Is the interface always available or do you, for example, need to cache data locally?
  * How is performance/scalability/security/etc catered for?
  * Has each interface been thought about from a non-technical perspective?
  * Who has ownership of the interface?
  * How often does the interface change and how is versioning handled?
  * Are there any service-level agreements in place?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Code
  Although other sections of the software guidebook describe the overall architecture of the
  software, often you’ll want to present lower level details to explain how things work. This is
  what the code section is for. Some software architecture documentation templates call this
  the “implementation view” or the “development view”.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Code
  * Generating/rendering HTML: a short description of an in-house framework that was created for generating HTML, including the major classes and concepts.
  * Data binding: our approach to updating business objects as the result of HTTP POST requests.
  * Multi-page data collection: a short description of an in-house framework we used for building forms that spanned multiple web pages.
  * Web MVC: an example usage of the web MVC framework that was being used.
  * Security: our approach to using Windows Identity Foundation (WIF) for authentication and authorisation.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Code
  * Domain model: an overview of the important parts of the domain model.
  * Component framework: a short description of the framework that we built to allow components to be reconfigured at runtime.
  * Configuration: a short description of the standard component configuration mechanism in use across the codebase.
  * Architectural layering: an overview of the layering strategy and the patterns in use to implement it.
  * Exceptions and logging: a summary of our approach to exception handling and logging across the various architectural layers.
  * Patterns and principles: an explanation of how patterns and principles are implemented.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Data
  The data associated with a software system is usually not the primary point of focus yet it’s
  arguably more important than the software itself, so often it’s useful to document something
  about it.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Data
  * What does the data model look like?
  * Where is data stored?
  * Who owns the data?
  * How much storage space is needed for the data? (e.g. especially if you’re dealing with “big data”)
  * What are the archiving and back-up strategies?
  * Are there any regulatory requirements for the long term archival of business data?
  * Likewise for log files and audit trails?
  * Are flat files being used for storage? If so, what format is being used?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Infrastructure Architecture
  While most of the software guidebook is focussed on the software itself, we do also
  need to consider the infrastructure because software architecture is about software and
  infrastructure.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Infrastructure Architecture
  This section is used to describe the physical/virtual hardware and networks on which the
  software will be deployed. Although, as a software architect, you may not be involved in
  designing the infrastructure, you do need to understand that it’s sufficient to enable you to
  satisfy your goals. The purpose of this section is to answer the following types of questions:

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Infrastructure Architecture
  * Is there a clear physical architecture?
  * What hardware (virtual or physical) does this include across all tiers?
  * Does it cater for redundancy, failover and disaster recovery if applicable?
  * Is it clear how the chosen hardware components have been sized and selected?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Infrastructure Architecture
  * If multiple servers and sites are used, what are the network links between them?
  * Who is responsible for support and maintenance of the infrastructure?
  * Are there central teams to look after common infrastructure (e.g. databases, message buses, application servers, networks, routers, switches, load balancers, reverse proxies, internet connections, etc)?
  * Who owns the resources?
  * Are there sufficient environments for development, testing, acceptance, pre-production, production, etc?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Deployment
  The deployment section is simply the mapping between the software and the infrastructure.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Deployment
  This section is used to describe the mapping between the software (e.g. containers) and
  the infrastructure. Sometimes this will be a simple one-to-one mapping (e.g. deploy a web
  application to a single web server) and at other times it will be more complex (e.g. deploy
  a web application across a number of servers in a server farm). This section answers the
  following types of questions:

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Deployment
  * How and where is the software installed and configured?
  * Is it clear how the software will be deployed across the infrastructure elements described in the infrastructure architecture section? (e.g. one-to-one mapping, multiple containers per server, etc)
  * If this is still to be decided, what are the options and have they been documented?
  * Is it understood how memory and CPU will be partitioned between the processes running on a single piece of infrastructure?
  * Are any containers and/or components running in an active-active, active-passive, hot-standby, cold-standby, etc formation?
  * Has the deployment and rollback strategy been defined?
  * What happens in the event of a software or infrastructure failure?
  * Is it clear how data is replicated across sites?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Operation and Support
  The operations and support section allows you to describe how people will run, monitor and
  manage your software.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Operation and Support
  Most systems will be subject to support and operational requirements, particularly around
  how they are monitored, managed and administered. Including a dedicated section in the
  software guidebook lets you be explicit about how your software will or does support those
  requirements. This section should address the following types of questions:

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Operation and Support
  * Is it clear how the software provides the ability for operation/support teams to monitor and manage the system?
  * How is this achieved across all tiers of the architecture?
  * How can operational staff diagnose problems?
  * Where are errors and information logged? (e.g. log files, Windows Event Log, SMNP, JMX, WMI, custom diagnostics, etc)
  * Do configuration changes require a restart?
  * Are there any manual housekeeping tasks that need to be performed on a regular basis?
  * Does old data need to be periodically archived?

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Development Environment
  The development environment section allows you to summarise how people new to your
  team install tools and setup a development environment in order to work on the software.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Development Environment
  The purpose of this section is to provide instructions that take somebody from a blank
  operating system installation to a fully-fledged development environment.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Development Environment
  * Pre-requisite versions of software needed.
  * Links to software downloads (either on the Internet or locally stored).
  * Links to virtual machine images.
  * Environment variables, Windows registry settings, etc.
  * Host name entries.
  * IDE configuration.
  * Build and test instructions.
  * Database population scripts.
  * Usernames, passwords and certificates for connecting to development and test services.
  * Links to build servers.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \### Development Environment
  If you’re using automated solutions (such as Vagrant, Docker, Puppet, Chef, Rundeck, etc), it’s still worth including some brief information about how these solutions work, where to find the scripts and how to run them.

%section{"data-markdown" => ""}
  \#### Software Guidebook
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben

  * Was waren die Gründe für Softwarearchitektur?
  * Was sollte eine Kontext-Sicht enthalten?
  * In welcher Beziehung stehen Architektur und Design?
  * Was besagt 'Conways Law'?
  * Nennen und erläutern Sie drei Arten von Architekturmustern
  * Für welche Systeme wird das MVC Muster typischerweise verwendet?

%section{"data-markdown" => ""}
  \## Fragen?

  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
