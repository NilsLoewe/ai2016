---
title: Vorlesung 7 - Architekturmuster
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule für angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils Löwe / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \## 3. Praktikum
  [Praktikum 3: Architekturentwurf](https://ai2016.nils-loewe.de/p03.html)
  \### Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Wiederholung
  \### Architekturmuster

%section
  %h4
    Ein Architekturmuster beschreibt eine bewährte Lösung für ein wiederholt auftretendes Entwurfsproblem
  %p
    %i (Effektive Softwarearchitekturen)

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \### Domain-driven Design

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design ist nicht nur eine Technik oder Methode. Es ist viel mehr eine Denkweise und
    Priorisierung zur Steigerung der Produktivität von Softwareprojekten im Umfeld komplexer fachlicher
    Zusammenhänge

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design basiert auf folgenden zwei Annahmen:
  %ul
    %li Der Schwerpunkt des Softwaredesigns liegt auf der Fachlichkeit und der Fachlogik.
    %li Der Entwurf komplexer fachlicher Zusammenhänge sollte auf einem Modell der Anwendungsdomäne, dem Domänenmodell basieren.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Bestandteile des Domänenmodells
  %p Domain-driven Design unterscheidet die folgenden Bestandteile des Domänenmodells:
  %br
  ![](/images/DomainDrivenDesign_map.png)

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \### Architekturtechniken
  \#### Evolvierende Struktur (evolving order)
  \#### Systemmetapher (system metaphor)
  \#### Verantwortlichkeitsschichten (responsibility layers)
  \#### Wissenslevel (knowledge level)
  \#### Erweiterungsframeworks (pluggable component framework)

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### "SOA ist ein Paradigma für die Strukturierung und Nutzung verteilter Funktionalität, die von unterschiedlichen Besitzern verantwortet wird."

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * SOA soll Dienste von IT-Systemen strukturieren und zugänglich machen.
  * SOA orientiert sich an Geschäftsprozessen
  * Geschäftsprozesse sind die Grundlage für konkrete Serviceimplementierungen

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \#### Beispiel für einen Geschäftsprozess: **„Vergib einen Kredit“**

  * Auf einer hohen Ebene angesiedelt
  * Zusammengesetzt aus
  * _„Eröffnen der Geschäftsbeziehung“_
  * _„Eröffnen eines oder mehrerer Konten“_
  * _„Kreditvertrag“_

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  * Ein Dienst ist eine IT-Repräsentation von fachlicher Funktionalität.
  * Ein Dienst ist in sich abgeschlossen (autark) und kann eigenständig genutzt werden.
  * Ein Dienst ist in einem Netzwerk verfügbar.
  * Ein Dienst hat eine wohldefinierte veröffentlichte Schnittstelle (Vertrag). Für die Nutzung reicht es, die Schnittstelle zu kennen. Kenntnisse über die Details der Implementierung sind hingegen nicht erforderlich.

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Vorteile
  * Eine agile IT-Umgebung, die schnell auf geschäftliche Veränderungen reagieren kann
  * Niedrigere Gesamtbetriebskosten durch die Wiederverwendung von Services
  * Höhere Leistung, größere Skalierbarkeit und Transparenz
  * Dienstleistungen und Produkte können schneller auf den Markt gebracht werden

%section{"data-markdown" => ""}
  \#### Serviceorientierte Architektur (SOA)

  \### Nachteile
  * SOA wird von Marketingabteilungen gehyped: Einführung von SOA ist die Lösung aller bisherigen Probleme
  * SOA generiert einen höheren Aufwand als bisherige monolithische Programmstrukturen.
  * SOA erzeugt im Code wesentlich komplexere Abläufe
  * SOA setzt für die beteiligten Entwickler ein erhebliches Know-how voraus.
  * _Somit sind Entwickler auch nicht so einfach ersetzbar, und die Abhängigkeit der Unternehmen von einzelnen Entwicklern steigt deutlich._

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \### Peer-to-Peer
  \#### Client-Server

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### In einem reinen Peer-to-Peer-Netz sind alle Computer gleichberechtigt und können sowohl Dienste in Anspruch nehmen, als auch zur Verfügung stellen.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer
  ![](/images/PeerToPeer.jpg)

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \#### Typische Eigenschaften:

  * Hohe Heterogenität bezüglich der Bandbreite, Rechenkraft, Online-Zeit
  * Die Verfügbarkeit und Verbindungsqualität der Peers kann nicht vorausgesetzt werden
  * Peers bieten Dienste und Ressourcen an und nehmen Dienste anderer Peers in Anspruch
  * Dienste und Ressourcen können zwischen allen teilnehmenden Peers ausgetauscht werden.
  * Peers haben eine signifikante Autonomie (über die Ressourcenbereitstellung).
  * Das P2P-System ist selbstorganisierend.

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Vorteile
  * alle Computer sind gleichberechtigt
  * Kostengünstiger als Servernetzwerke
  * Kein leistungsstarker zentraler Server erforderlich
  * Keine spezielle Netzwerksoftware erforderlich
  * Benutzer verwalten sich selbst
  * Keine hierarchische Netzwerkstruktur

%section{"data-markdown" => ""}
  \#### Peer-to-Peer

  \### Nachteile
  * Zentrale Sicherheitsaspekte sind nicht von Bedeutung
  * Sehr schwer zu administrieren
  * kein einziges Glied im System ist verlässlich

%section{"data-markdown" => ""}
  \##### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \### Client-Server

%section{"data-markdown" => ""}
  \#### Client-Server

  \### Das Client-Server-Modell verteilt Aufgaben und Dienstleistungen innerhalb eines Netzwerkes.

%section{"data-markdown" => ""}
  \#### Client-Server

  * Der Client kann auf Wunsch einen Dienst vom Server anfordern
  * Der Server beantwortet die Anforderung.
  * Üblicherweise kann ein Server gleichzeitig für mehrere Clients arbeiten.

%section{"data-markdown" => ""}
  \#### Client-Server
  ![](/images/client-server.jpg)

%section{"data-markdown" => ""}
  \#### Client-Server

  * Clients und Server können als Programme auf verschiedenen Rechnern oder auf demselben Rechner ablaufen.
  * Das Konzept kann zu einer Gruppe von Servern ausgebaut werden, die eine Gruppe von Diensten anbietet.
  * In der Praxis laufen Server-Dienste meist gesammelt auf bestimmten Rechnern, die dann selber "Server" genannt werden

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Vorteile
  * Gute Skalierbarkeit
  * Einheitliches Auffinden von Objekten

%section{"data-markdown" => ""}
  \#### Client-Server
  \### Nachteile
  * Der Server muss immer in Betrieb sein
  * Der Server muss gegen Ausfall und Datenverlust gesichert werden

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  Das MVC-Pattern ist eine spezielle Variante des Layers-Pattern, die sich aus den
  drei Schichten Datenhaltung (Model), Programmlogik (Controller) und Präsentation (View) zusammensetzt.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)

  * Model: Speicherung und Zugriffskontrolle von Daten
  * View: Darstellung der Daten für die Anwender
  * Controller: Vermittlung zwischen View und Model

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  ![](/images/mvc.png)


%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Model

  * Das Modell kapselt Kerndaten und Funktionalität.
  * Das Modell ist unabhängig von einer bestimmten Darstellung der Ausgabe oder einem bestimmten Verhalten der Eingabe.
  * Das Modell bildet die Kernfunktionalität der Anwendung ab.
  * (Das Modell benachrichtigt registrierte bei Datenänderungen.)

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: View

  * Die Sicht (view) zeigt dem Benutzer Informationen an.
  * Es kann mehrere Sichten pro Modell geben.
  * Ggf. zugeordnete Eingabeelemente anzeigen

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Teilnehmer: Controller

  * Der Controller verarbeitet Eingaben und ruft passende Dienste der zugeordeten Sicht oder des Modells auf.
  * Jede Controller ist einer Sicht zugeordnet
  * Es kann mehrere Controller pro Modell geben.

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Vorteile

  * Mehrere Sichten desselben Modells
  * Automatische Synchronisation aller Views
  * Austauschbarkeit von Views und Controllern
  * Gute Trennung von Modell und View
  * Potential für vorgefertigte Frameworks

%section{"data-markdown" => ""}
  \#### Model View Controller (MVC)
  \### Nachteile
  * Erhöhte Komplexität
  * Starke Kopplung zwischen Modell und View
  * Starke Kopplung zwischen Modell und Controller
  * Potential für unnötig häufige Aktualisierungen
  * Häufig ineffizienter Datenzugriff auf das Modell.
  * View und Controller sind schwer zu portieren.

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Model View Presenter

  \### Hervorgegangen aus dem Model-View-Controller (MVC) Architekturmuster.

  Vollständige Trennung von Model und View, Verbindung über einen Presenter.

%section{"data-markdown" => ""}
  \#### Model View Presenter

  * Vollständige Trennung von Model und View
  * Deutlich verbesserte Testbarkeit
  * Strenge Trennung der einzelnen Komponenten

%section{"data-markdown" => ""}
  \#### Model View Presenter (MVP)
  ![](/images/mvp.png)

%section{"data-markdown" => ""}
  \##### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \### Presentation-Abstraction-Control (PAC)

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hohe Flexibilität für ein System, das aus vielen autarken Einzelsystemen zusammengesetzt ist.

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  * Große Systeme, für die das Model-View-Controller-Muster nicht ausreicht
  * Aufteilung des Systems in zwei Richtungen
  * --> In die drei Einheiten Presentation, Control und Abstraction (ähnlich dem MVC)
  * --> Hierarchisch in verschiedene Teile („Agenten“), die jeweils einen Teil der Aufgaben des Systems anbieten

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Agenten

  * Stellen die erste Stufe der Strukturierung während des Architekturentwurfes dar
  * Aufteilung der gesamten Anforderungen auf einzelne Agenten
  * Aufbau der hierarchischen Struktur
  * Für jeden Agenten erfolgt dann eine Aufteilung in Presentation, Abstraction und Control

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Hierarchie: Drei Schichten

  * Top-Level-Agent: Globale Aufgaben
  * Intermediate-Level-Agenten: Strukturierung der Bottom-Level-Agenten
  * Bottom-Level-Agenten: Konkrete, abgeschlossene Aufgaben

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Aufteilung der Agenten

  * Nicht jeder Agent muss alle drei Komponenten implementieren
  * Jeder Agent bringt die Benutzerschnittstelle und das Datenmodell für seine Aufgabe mit
  * Jeder Agent muss die Control implementieren, um über sie die Kommunikation mit anderen Agenten und zwischen den Komponenten zu ermöglichen

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Vorteile
  * Zerlegung der Funktionen des Gesamtsystems in einzelne semantisch getrennte Teile
  * Gute Erweiterbarkeit durch neue Agenten
  * Gute Wartbarkeit ist durch die interne Struktur der Agenten

%section{"data-markdown" => ""}
  \#### Presentation-Abstraction-Control (PAC)

  \### Nachteile
  * Erhöhte Systemkomplexität
  * Erhöhter Koordinations- und Kommunikationsaufwand zwischen den Agenten
  * Die Steuerungskomponenten können eine hohe Komplexität erreichen

%section{"data-markdown" => ""}
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \### Adaptive Systeme

%section{"data-markdown" => ""}
  \##### Adaptive Systeme
  \### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Ziel: Änderung von Systemanforderungen zur Laufzeit dynamisch begegnen.

%section{"data-markdown" => ""}
  \#### Mikrokernel

  \### Aufgaben
  * Der Mikrokernel bietet die Basis für mögliche Erweiterungen
  * Der Microkernel koordiniert die Zusammenarbeit.

%section{"data-markdown" => ""}
  \#### Microkernel
  \### Herausforderung

  ![](/images/microkernel.png)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Microkernel

  * Minix Kernel
  * GNU Mach
  * AmigaOS
  * SymbianOS

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Monolithische Kernels

  * Linux
  * Android
  * Windows bis Win98 (DOS Kernel)

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Beispiele: Hybrid-Kernels

  * MacOS X (Darwin)
  * Windows NT (oft als Microkernel bezeichnet)


%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Vorteile

  * Separierte Komponenten: Austauschbarkeit
  * Treiber im Benutzer-Modus: Sicherheit
  * kleine Trusted Computing Base
  * Skalierbarkeit
  * Zuverlässigkeit
  * Transparenz

%section{"data-markdown" => ""}
  \#### Mikrokernel
  \### Nachteile

  * Leistung
  * Komplexität

%section{"data-markdown" => ""}
  \### Fragen?

%section{"data-markdown" => ""}
  \### Domain Driven Design
  \## Ein Beispiel

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Eine Firma bietet Softwareentwicklung als Dienstleistung an.

  \###### http://blog.mirkosertic.de/architecturedesign/dddexample

  * Aufwand wird nach Stunden verrechnet
  * Es gibt festangestellte Softwareentwickler
  * Es gibt einen Pool von Freelancern.
  * Bisher wird die Zuordnung von Entwicklern zu Projekten in einem Excel-Sheet organisiert


%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Probleme mit dem Excel-Ansatz

  * Excel skaliert nicht auf mehrere Anwender
  * Keine Sicherheit
  * Kein Logging

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel
  \### Lösung: Neue Software bauen

  * Durchsuchbarer Katalog von Freelancern
  * Mehrere Kontaktmöglichkeiten pro Freelancer
  * Durchsuchbarer Katalog von Projekten
  * Durchsuchbarer Katalog von Projekten
  * Timesheets für jeden Freelancer (pro Projekt)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddfirstrun.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  \### Straight forward Ansatz
  * Kunden
  * Freelancer
  * Projekte
  * Timesheets
  * User Management: Rolle

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz
  \### Probleme?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Großer Objektgraph: Performance Probleme unter Last
  Framework wie Hibernate wäre notwendig um das zu vermeiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Warum die bidirektionale Verknüpfung zwischen User und Rolle?

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Boolean-Flags um den Kontakttypen zu unterscheiden

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  \### Projekt-Liste in der Freelancer-Klasse:
  \#### Freelancer verändern um Projekte zuzufügen
  Potentielle Transaktionsprobleme unter Last (mehrere Leute legen gleichzeitig Projekte für den gleichen Kunden an)

%section{"data-markdown" => ""}
  \#### Straight forward Ansatz: Probleme
  * Kontaktinformation == Kommunikationskanal?
  * Das Diagramm ist eher ein Entiy-Relationship-Diagram als ein Software Modell
  * Wo ist die Businesslogik?

%section{"data-markdown" => ""}
  \### DDD nutzen

  * Gemeinsame Sprache schaffen um zwischen Entwicklern und Domänenexperten zu vermitteln
  * Komplexität reduzieren durch OO-Design Prinzipien

%section{"data-markdown" => ""}
  \#### DDD nutzen
  \#### Anforderungen: "Body Leasing Domain"
  \### **Context-Map: Komplexität reduzieren durch Subdomains**

  * Identität und Access Management Subdomain
  * Freelancer Management Subdomain
  * Kundenmanagement Subdomain
  * Projektmanagement Subdomain

%section{"data-markdown" => ""}
  \#### DDD - Context Map
  ![](/images/dddcontextmap.png)

%section{"data-markdown" => ""}
  \#### DDD - Bounded Context

  * Zuordnen von Subdomains zu Teilen der Lösung
  * *Building blocks* nutzen (Design Pattern anwenden)
  * Die DDD Architekturpattern sind nicht technologieabhängig!

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddrevised.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Bounded Contexts für jede Subdomain
  * Bounded Contexts sind isoliert und unabhängig
  * Verbindungen durch common types (UserId, ProjectId, CustomerId): “Generic Subdomain”

%section{"data-markdown" => ""}
  \#### DDD - Ein erster Ansatz

  * Jeder Bounded Context enthält Aggregates und Wertobjekte
  * Aggregates sind Objekthierarchien
  * Nur das Root-Objekt eines Aggregates ist von außen zugreifbar
  * Jeder Zugriff auf ein Objekt passiert durch die Aggregates: Bessere Kapselung
  * Aggregates und Entites besitzen eine ID
  * Wertobjekte haben keine ID und können ihren Zustand nicht ändern
  * Jede Zustandsänderung erzeugt ein neues Wertobjekt: Vermeiden von Seiteneffekten

%section{"data-markdown" => ""}
  \#### DDD - Beschreibung von Verhalten

  \### Use Case: “Freelancer zieht um”

%section{"data-markdown" => ""}
  \#### Entwurf ohne DDD

  ![](/images/dddbehavior.png)

%section{"data-markdown" => ""}
  \#### DDD - Probleme

  * Name etc. ändern durch Setter-Methoden
  * Setter können von diversen Orten aufgerufen werden
  * Rollenbasierte Security schwer umsetzbar
  * Kein Kontext des Aufrufers bekannt
  * Kein "Adress-Konzept", lediglich einzelne Felder

%section{"data-markdown" => ""}
  \#### Entwurf mit DDD

  ![](/images/dddbehaviorrevised.png)

%section{"data-markdown" => ""}
  \#### DDD Ansatz - Vorteile

  * Der Freelancer hat nur ein Attribut: Die Adresse
  * Eine Adresse ist immutable, Änderungen erzeugen neue Adress-Objekte
  * getAdress gibt ein immutable Adress-Objekt zurück
  * movedTo(Adress) bildet explizit den UseCase ab
  * Rollenbasierte Security ist möglich

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Persistenz in DDD wird mit "Repositories" umgesetet
  * Ein Repository ist durchsuchbar, kann Instanzen liefern und löschen, sowie neue Instanzen ablegen
  * Es sollte ein Repository für jedes Aggregate geben

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  ![](/images/dddusecasepersistence.png)

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Ein Client ist ein abstraktes Konzept
  * Ein Client kann alles von einem Frontend über einen SOAP Webservice zu einer REST Ressource sein
  * Ein Client sendet Befehle an den ApplciationService

%section{"data-markdown" => ""}
  \#### Vollständiger UseCase mit Persistenz

  * Der ApplicationService setzt die Befehle in UseCases um
  * Der FreelancerApplicationService lädt dasFreelancer Aggregate aus dem FreelancerRepository und ruft moveTo() auf dem FreelancerAggregate auf
  * Der FreelancerApplicationService bildet dabei die Transactionsgrenzen.
  * Jeder Aufruf erzeugt eine neue Transaktion

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  * Jeder Bounded Context sollte eine "Deployment Unit" bilden, z.B. ein Java WAR file oder ein EJB JAR
  * Die Bounded Contexts sind unabhängig designt, sie sollten daher auch unabhängig implementiert werden

%section{"data-markdown" => ""}
  \#### DDD - Applikations-Architektur

  \### Jede Deployment Unit enthält die folgenden Elemente:

  * Domain Layer: Domänenlogik
  * Infrastructure Layer: Technologieabhängige Artefakte (z.B. Hibernate für Repository)
  * Application Layer: Gateway zur Businesslogik mit Transaktionskontrolle

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer1.png)

%section{"data-markdown" => ""}
  \#### DDD - Layers

  ![](/images/dddlayer2.png)

%section{"data-markdown" => ""}
  \#### DDD - Vorteile

  * Der Domain Layer basiert nicht auf anderen Teilen der Architektur
  * Die Repository Implementierung kann getauscht werden, ohne die Businesslogik zu beeinflusseng any business logic.

%section{"data-markdown" => ""}
  \#### DDD -  Domain Layer

  * Enthält die Businesslogik, keine Abhängigkeiten der Infrastruktur
  * Die Modelle sollten nach dem CQS(Command-Query-Separation) Prinzip entworfen werden
  * --> Query Methoden geben lediglich Daten zurück ohne Zustände zu ändern
  * --> Command Methoden ändern den Stade

%section{"data-markdown" => ""}
  \#### DDD - Application Layer

  * Der Application Layer nimmt Kommandos des User Interface Layer an
  * Der Application Layer ruft UseCase Implementierungen im Domain layer auf
  * Der Application Layer biete Transactioskontrolle für Business Operationen

%section{"data-markdown" => ""}
  \#### DDD - Infrastructure Layer

  Der Infrastructure Layer bietet Infrastrukturabhängige Teile für alle anderen Layer


%section{"data-markdown" => ""}
  \#### DDD - User Interface Layer

  * Der User Interface Layer konsumiert Application Services und ruft Funktionalität der Businesslogik auf diesen Services auf.
  * Jeder Aufruf ist eine neue Transaktion
  * Der User Interface Layer kann beliebig implementiert sein, z.B. ein SOAP webservice, eine REST Resource oder eine Swing/AWT GUI

%section{"data-markdown" => ""}
  \#### DDD - Context Integration

  \### Anforderungen:
  * Ein Kunde kann nur gelöscht werden, wenn er keinem aktiven Projekt zugeordnet ist
  * Wenn ein Timesheet erstellt wurde, muss eine Rechnung erstellt werden

%section{"data-markdown" => ""}
  \#### DDD - Context Integration

  * *Customer Management Bounded Context* prüft ob ein Projekt für den übergebenen Kunden existiert, bevor der Kunde gelöscht werden kann.
  * Ziel: *Bounded Contexts* sollen unabhängig bleiben

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (synchron)

  ![](/images/dddsyncexample1.png)

%section{"data-markdown" => ""}
  \#### DDD - *Domain Service*

  * Ein *Domain Service* implementiert Business Logik, die nicht durch eine Entity, Aggragate oder ValueObject implementiert werden kann.
  * Z.B. wenn Business Logik Operationen betreffen mehrere *Domain Objects* oder Interaktionen mit anderen *Bounded Contexts*

  * *ApplicationService* ruft *deleteCustomerById* des *CustomerService* auf
  * *CustomerService* ruft *ProjectManagementAdapter* durch *customerExists()* auf
  * Ein Kunde wird nur aus dem CustomerRepository gelöscht, wenn *customerExists()* false zurückgibt.

%section{"data-markdown" => ""}
  \#### DDD - *Domain Service*

  * Es existieren zwei Implementierungen des *ProjectManagementAdapter*, basierend auf SOAP und REST
  * Die Implementierung kann leicht verändert werden ohne den DomainLayer zu beeinflussen

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (synchron)

  ![](/images/dddsyncexample2.png)

%section{"data-markdown" => ""}
  \#### DDD - Transaktionsgrenzen

  * WebService oder REST Ressourcen bieten keine automatischen Transaktionen
  * XA/two-phase-commit erhöht die Komplexität und rediziert die Skalierbarkeit
  * Besser wäre es, Kunden nicht zu löschen, sondern als logisch gelöscht zu markieren
  * --> Bei Transaktionsfehlern lässt sich der originale Zustand wiederherstellen

%section{"data-markdown" => ""}
  \#### DDD - Ein komplexeres Beispiel

  \### Wenn ein Timesheet abgegeben wurde, soll eine Rechnung erstellt werden

  * Synchronität ist nicht notwendig: Die Rechnung kann auch Stunden später oder am Monatsende erstellt werden.
  * Die Rechnung kann in einem anderen System weiterverarbeitet werden, das nicht Teil unseres Systems ist

%section{"data-markdown" => ""}
  \#### DDD - Ein komplexeres Beispiel

  \#### "Wenn ein Timesheet abgegeben wurde..." ist ein Business-Event

  * Domain Events werden erzeugt und im Event Store gespeichert und von dort weiterverarbeitet
  * Der Event Store ist Teil des Bounded Context
  * Das Bearbeiten von Domain-Events in einer Transaktion ist ist Aufgabe des ApplicationService
  * Auf Seite der Infrastruktur werden gespeicherte Events mit einer Messaging Technologie wie JMS oder AMQP ausgeliefert

%section{"data-markdown" => ""}
  \#### DDD - Wozu ein lokaler Eventstore?

  * Die Messaging Infrastruktur könnte ausgefallen sein
  * Der Bounded Context sollte nicht abhängig von Infrastrukturproblemen sein
  * --> Events werden gespeichert bis die Infrastruktur wieder verfügbar ist
  * Messaging vermeidet unnötig enge Kopplung von Systemen

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (asynchron)

  ![](/images/dddasyncexample1.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel

  * Der *FreelancerService* erzeugt ein *TimesheetEntered*  Domain-Event
  * Das Event wird zum *EventStore* weitergeleitet
  * Der *JMSMessagingAdapter* nimmt Events aus dem EventStore und leitet sie an die Messaging-Infrastruktur weiter

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (asynchron)

  ![](/images/dddasyncexample2.png)

%section{"data-markdown" => ""}
  \#### DDD - Ein Beispiel (asynchron)

  * Auch hier muss der Infrastruktur-Layer global verfügbar sein
  * Der *JMSMessageReceiver* liegt im Infrastruktur-Layer
  * Der *CustomerApplicationService* benutzt den *CustomerService*
  * Die Transaktionsgrenzen sind der *ApplicationService*

%section{"data-markdown" => ""}
  \#### DDD - Event de-duplication

  * Bei Infrastruktur-Problemen können Events doppelt versendet werden
  * Lösung: Eindeutige ID für Events + Tracking der verarbeiteten Events

%section{"data-markdown" => ""}
  \#### DDD - Zusammenfassung

  * Auch sehr komplexe Domänenlogik kann relativ einfach modelliert werden
  * Die Systeme werden besser entkoppelt und wartbar

%section{"data-markdown" => ""}
  \#### DDD - Zusammenfassung

  \### Domain-driven Design is object oriented programming done right. *(Eric Evans)*

%section{"data-markdown" => ""}
  \### Rückblick auf Architekturmuster

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section
  %h3 Chaos zu Struktur / Mud-to-structure
  %ul
    %li Organisation der Komponenten und Objekte eines Softwaresystems
    %li Die Funktionalität des Gesamtsystems wird in kooperierende Subsysteme aufgeteilt
    %li Zu Beginn des Softwareentwurfs werden Anforderungen analysiert und spezifiziert
    %li Integrierbarkeit, Wartbarkeit, Änderbarkeit, Portierbarkeit und Skalierbarkeit sollen berücksichtigt werden

%section{"data-markdown" => ""}
  \### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h3 Verteilte Systeme
  %ul
    %li Verteilung von Ressourcen und Dienste in Netzwerken
    %li Kein "zentrales System" mehr
    %li Basiert auf guter Infrastruktur lokaler Datennetze

%section{"data-markdown" => ""}
  \### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section
  %h3 Interaktive Systeme
  %ul
    %li Strukturierung von Mensch-Computer-Interaktionen
    %li Möglichst gute Schnittstellen für die Benutzer schaffen
    %li Der eigentliche Systemkern bleibt von der Benutzerschnittstelle unangetastet.

%section{"data-markdown" => ""}
  \### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section
  %h3 Adaptive Systeme
  %ul
    %li Unterstützung der Erweiterungs- und Anpassungsfähigkeit von Softwaresystemen.
    %li Das System sollte von vornherein mögliche Erweiterungen unterstützen
    %li Die Kernfunktionalität sollte davon unberührt bleiben kann.

%section{"data-markdown" => ""}
  \### Adaptive Systeme
  \#### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \### Wie wähle ich denn nun das passende Muster aus?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### Nutzen von Templates

  Beispiele:
  * arc42
  * Normen
  * ...

%section{"data-markdown" => ""}
  \### ARC42
  \#### (Dr. Gernot Starke / Dr. Peter Hruschka)
  http://www.arc42.de/

  \#### *arc42 unterstützt Software- und Systemarchitekten. Es kommt aus der Praxis und basiert auf Erfahrungen internationaler Architekturprojekte und Rückmeldungen vieler Anwender.*

%section{"data-markdown" => ""}
  \#### Dokumentation von Architekturen
  \### ARC42

  1. Einführung und Ziele
  2. Randbedingungen
  3. Kontextabgrenzung
  4. Lösungsstrategie
  5. Bausteinsicht
  6. Laufzeitsicht
  7. Verteilungssicht
  8. Querschnittliche Konzepte/Muster
  9. Entwurfsentscheidungen
  10. Qualitätsszenarien
  11. Risiken
  12. Glossar

%section{"data-markdown" => ""}
  \#### ARC42
  ![](/images/arc42.png)

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 1. Einführung und Ziele
  * Aufgabenstellung
  * Qualitätsziele
  * eine Kurzfassung der architekturrelevanten Anforderungen (insb. die nichtfunktionalen)
  * Stakeholder

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 2. Randbedingungen
  Welche Leitplanken schränken die Entwurfsentscheidungen ein?
  * Technische Randbedingungen
  * Organisatorische Randbedingungen
  * Konventionen

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 3. Kontextabgrenzung
  * Fachlicher Kontext
  * Technischer- oder Verteilungskontext

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 4. Lösungsstrategie
  Wie funktioniert die Lösung? Was sind die fundamentalen Lösungsansätze?

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 5. Bausteinsicht
  Die statische Struktur des Systems, der Aufbau aus Implementierungsteilen.

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 6. Laufzeitsicht
  Zusammenwirken der Bausteine zur Laufzeit, gezeigt an exemplarischen Abläufen ("Szenarien")

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 7. Verteilungssicht
  Deployment: Auf welcher Hardware werden die Bausteine betrieben?

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 8. Querschnittliche Konzepte und Muster
  * Wiederkehrende Muster und Strukturen
  * Fachliche Strukturen
  * Querschnittliche, übergreifende Konzepte
  * Nutzungs- oder Einsatzanleitungen für Technologien
  * Oftmals projekt-/systemübergreifend verwendbar!

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 9. Entwurfsentscheidungen
  ![](/images/entscheidung.png)

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 10. Qualitätsszenarien
  Qualitätsbaum sowie dessen Konkretisierung durch Szenarien

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 11. Risiken

  Eine nach Prioritäten geordnete Liste der erkannten Risiken

  \#### "Risikomanagement ist Projektmanagement für Erwachsene"

%section{"data-markdown" => ""}
  \#### ARC42
  \#### 12. Glossar
  Die wichtigsten Begriffe der Software-Architektur in alphabetischer Reihenfolge

%section{"data-markdown" => ""}
  \#### ARC42
  \## Fragen?

%section{"data-markdown" => ""}
  \### IEEE Standards

  **IEEE Standards** documents are developed within the IEEE Societies and the Standards Coordinating Committees of
  the IEEE Standards Association (IEEE-SA) Standards Board. The IEEE develops its standards through a consensus
  development process, approved by the American National Standards Institute, which brings together volunteers representing
  varied viewpoints and interests to achieve the final product. Volunteers are not necessarily members of the
  Institute and serve without compensation. While the IEEE administers the process and establishes rules to promote
  fairness in the consensus development process, the IEEE does not independently evaluate, test, or verify the accuracy
  of any of the information contained in its standards or implementations thereof.

%section{"data-markdown" => ""}
  \### IEEE Standards

  * IEEE 802:    LAN
  * IEEE 802.3:  Carrier sense multiple access with collision detection (CSMA/CD)
  * IEEE 802.11: Wireless LAN
  * IEEE 830:    Recommended Practice for Software Requirements Specifications
  * IEEE 1394:   FireWire/i.Link Bussysteme
  * IEEE 1471:   Recommended Practice for Architectural Description of Software-Intensive Systems
  * IEEE 9945:   Portable Operating System Interface (POSIX®)

%section{"data-markdown" => ""}
  \### IEEE 830-1998

%section{"data-markdown" => ""}
  \#### IEEE
  \## Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### Qualiät und andere nichtfunktionale Anforderungen
  \#### Architekturmuster
  \### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}

  \#### Vorbereitung auf Klausuraufgaben

  * Was waren die Gründe für Softwarearchitektur?
  * Was sollte eine Kontext-Sicht enthalten?
  * In welcher Beziehung stehen Architektur und Design?
  * Was besagt 'Conways Law'?
  * Nennen und erläutern Sie drei Arten von Architekturmustern
  * Für welche Systeme wird das MVC Muster typischerweise verwendet?

%section{"data-markdown" => ""}
  \## Fragen?

  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
