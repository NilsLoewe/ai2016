---
title: Vorlesung 5 - Architekturmuster II
layout: slide
---

%section{"data-markdown" => ""}
  \## Architektur von Informationssystemen
  \#### Hochschule fÃ¼r angewandte Wissenschaften
  \#### Sommersemester 2016
  Nils LÃ¶we / [nils@loewe.io](mailto:nils@loewe.io) / @NilsLoewe

%section{"data-markdown" => ""}
  \#### Praktikumsaufgabe
  [2. Praktikumsaufgabe](p02.html)

  \### Fragen?

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \### Wiederholung
  \### Architekturmuster

%section{"data-markdown" => ""}
  \### Was sind Architekturmuster?

%section
  %h4
    Ein Architekturmuster beschreibt eine bewÃ¤hrte LÃ¶sung fÃ¼r ein wiederholt auftretendes Entwurfsproblem
  %p
    %i (Effektive Softwarearchitekturen)

%section{"data-markdown" => ""}
  \### Warum Architekturmuster?

%section{"data-markdown" => ""}
  \#### Erfolg kommt von Weisheit.
  \#### Weisheit kommt von Erfahrung.
  \#### Erfahrung kommt von Fehlern.

%section{"data-markdown" => ""}
  \#### Aus Fehlern kann man hervorragend lernen.
  Leider akzeptiert kaum ein Kunde Fehler, nur weil Sie Ihre Erfahrung als Software-Architekt sammeln.

%section{"data-markdown" => ""}
  \#### In dieser Situation helfen Heuristiken.
  Heuristiken kodifizieren Erfahrungen anderer Architekten und Projekte, auch aus anderen Bereichen der Systemarchitektur.

%section{"data-markdown" => ""}
  \#### Heuristiken bieten Orientierung im Sinne von Wegweisern, StraÃŸenmarkierungen und Warnschildern.
  Sie geben allerdings lediglich Hinweise und garantieren nichts. Es bleibt in Ihrer Verantwortung, die passen-
  den Heuristiken fÃ¼r eine bestimmte Situation auszuwÃ¤hlen:

%section{"data-markdown" => ""}
  \#### Die Kunst der Architektur liegt nicht in der Weisheit der Heuristiken, sondern in der Weisheit, a priori die passenden Heuristiken fÃ¼r das aktuelle Projekt auszuwÃ¤hlen.

%section{"data-markdown" => ""}
  \### Architektur: Von der Idee zur Struktur
  Ein klassischer und systematischer Ansatz der Beherrschung von KomplexitÃ¤t lautet â€žteile
  und herrscheâ€œ (divide et impera). Das Problem wird in immer kleinere Teile zerlegt, bis diese
  Teilprobleme eine Ã¼berschaubare GrÃ¶ÃŸe annehmen.

%section{"data-markdown" => ""}
  \### Horizontale Zerlegung
  \#### Jede Schicht stellt einige klar definierte Schnittstellen zur VerfÃ¼gung und nutzt Dienste von darunter liegenden Schichten.

%section{"data-markdown" => ""}
  \### Vertikale Zerlegung
  \#### Jeder Teil Ã¼bernimmt eine bestimmte fachliche oder technische Funktion.

%section
  %h4 Prinzipien zur Zerlegung

  %h3 Kapselung (information hiding)
  %h3 Wiederverwendung
  %h3 Iterativer Entwurf
  %h3 Dokumentation von Entscheidungen
  %h3 UnabhÃ¤ngigkeit der Elemente

%section{"data-markdown" => ""}
  \### Ein Praxisbericht
  [Why a service oriented architecture is not the holy grail...](https://www.youtube.com/watch?v=K03JnT0vys4&feature=youtu.be)

  %ul
    %li 1. Die falsche Zerlegung erhÃ¶ht die KomplexitÃ¤t!
    %li 2. Microservices sind keine LÃ¶sung fÃ¼r organisatorische Probleme
    %li 3. Neue Probleme ersetzen alte Probleme, z.B. AbhÃ¤ngigkeiten im Deployment

%section{"data-markdown" => ""}
  \#### Was ist Softwarearchitektur?
  \#### Geschichte und Trends
  \#### Sichten auf Architekturen
  \#### QualiÃ¤t und andere nichtfunktionale Anforderungen
  \### Architekturmuster
  \#### Dokumentation von Architekturen
  \#### Technologien und Frameworks

%section{"data-markdown" => ""}
  \#### Ãœberblick Ã¼ber Architekturmuster
  \### *Arten von Architekturmustern?*

%section{"data-markdown" => ""}
  \#### Chaos zu Struktur / Mud-to-structure
  \#### Verteilte Systeme
  \#### Interaktive Systeme
  \#### Adaptive Systeme
  \#### Domain-spezifische Architektur

%section
  %h3 Chaos zu Struktur / Mud-to-structure
  %ul
    %li Organisation der Komponenten und Objekte eines Softwaresystems
    %li Die FunktionalitÃ¤t des Gesamtsystems wird in kooperierende Subsysteme aufgeteilt
    %li Zu Beginn des Softwareentwurfs werden Anforderungen analysiert und spezifiziert
    %li Integrierbarkeit, Wartbarkeit, Ã„nderbarkeit, Portierbarkeit und Skalierbarkeit sollen berÃ¼cksichtigt werden

%section{"data-markdown" => ""}
  \### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h3 Verteilte Systeme
  %ul
    %li Verteilung von Ressourcen und Dienste in Netzwerken
    %li Kein "zentrales System" mehr
    %li Basiert auf guter Infrastruktur lokaler Datennetze

%section{"data-markdown" => ""}
  \### Verteilte Systeme
  \#### Serviceorientierte Architektur (SOA)
  \#### Peer-to-Peer
  \#### Client-Server

%section
  %h3 Interaktive Systeme
  %ul
    %li Strukturierung von Mensch-Computer-Interaktionen
    %li MÃ¶glichst gute Schnittstellen fÃ¼r die Benutzer schaffen
    %li Der eigentliche Systemkern bleibt von der Benutzerschnittstelle unangetastet.

%section{"data-markdown" => ""}
  \### Interaktive Systeme
  \#### Model View Controller (MVC)
  \#### Model View Presenter
  \#### Presentation-Abstraction-Control (PAC)

%section
  %h3 Adaptive Systeme
  %ul
    %li UnterstÃ¼tzung der Erweiterungs- und AnpassungsfÃ¤higkeit von Softwaresystemen.
    %li Das System sollte von vornherein mÃ¶gliche Erweiterungen unterstÃ¼tzen
    %li Die KernfunktionalitÃ¤t sollte davon unberÃ¼hrt bleiben kann.

%section{"data-markdown" => ""}
  \### Adaptive Systeme
  \#### Mikrokernel
  \#### Reflexion
  \#### Dependency Injection

%section{"data-markdown" => ""}
  \### Anti-Patterns

%section{"data-markdown" => ""}
  \#### Anti-Patterns?
  Ein Anti-Pattern ist in der Softwareentwicklung ein hÃ¤ufig anzutreffender schlechter LÃ¶sungsansatz fÃ¼r
  ein bestimmtes Problem. Es bildet damit das GegenstÃ¼ck zu den Mustern (Entwurfsmuster, Analysemuster,
  Architekturmuster, â€¦), welche allgemein Ã¼bliche und bewÃ¤hrte ProblemlÃ¶sungsansÃ¤tze beschreiben.

%section{"data-markdown" => ""}
  \### Ãœberblick Ã¼ber Antipatterns
  \#### Projektmanagement Anti-Patterns
  \#### Architektur Anti-Pattern
  \#### Code Smells
  \#### Organisations Anti-Pattern

%section{"data-markdown" => ""}
  \### Projektmanagement Anti-Patterns
  \### Blendwerk
  \### AufgeblÃ¤hte Software
  \### Feature creep
  \### Scope creep
  \### Brooksâ€™sches Gesetz
  \### Death Sprint
  \### Death March

%section{"data-markdown" => ""}
  \#### Architektur Anti-Patterns
  \### Big Ball of Mud
  \### Gasfabrik
  \### Gottobjekt
  \### Innere-Plattform-Effekt
  \### Spaghetticode
  \### Sumo-Hochzeit

%section{"data-markdown" => ""}
  \#### Code Smells
  \### Zwiebel
  \### Copy and Paste
  \### Lavafluss
  \### Magische Werte
  \### Reservierte WÃ¶rter
  \### Unbeabsichtigte KomplexitÃ¤t

%section{"data-markdown" => ""}
  \#### Organisations Anti-Pattern
  \### Wunderwaffe
  \### Das Rad neu erfinden
  \### Das quadratische Rad neu erfinden
  \### Body ballooning
  \### Empire building
  \### Warme Leiche
  \### Single head of knowledge

%section{"data-markdown" => ""}
  \#### Organisations Anti-Pattern II
  \### Management nach Zahlen
  \### Vendor Lock-In
  \### Design by Committee
  \### Boat Anchor
  \### Dead End
  \### Swiss Army Knife

%section{"data-markdown" => ""}
  \### Blendwerk
  Das Blendwerk (englisch *Smoke and mirrors*) bezeichnet nicht fertige Funktionen, welche als fertig vorgetÃ¤uscht werden.

%section{"data-markdown" => ""}
  \### AufgeblÃ¤hte Software
  Als Bloatware (englisch *â€žaufblÃ¤henâ€œ*) wird Software bezeichnet, die mit Funktionen Ã¼berladen ist
  bzw. die Anwendungen sehr unterschiedlicher Arbeitsfelder ohne gemeinsamen Nutzen bÃ¼ndelt. FÃ¼r den
  Anwender macht dies das Programm unÃ¼bersichtlich, fÃ¼r Entwickler unwartbar.

%section{"data-markdown" => ""}
  \### Feature creep
  bezeichnet es, wenn der Umfang der zu entwickelnden FunktionalitÃ¤t in einem Projektplan
  festgehalten wird, diese aber dauernd erweitert wird.
  %p
  Der Kunde versucht, nach der Erstellung des Projektplanes weitere FunktionalitÃ¤t
  mit unterzubringen. Dies fÃ¼hrt zu Problemen, wenn die in Arbeit befindliche Version nicht das
  notwendige Design aufweist, Termine nicht eingehalten werden kÃ¶nnen oder die realen Kosten
  Ã¼ber die planmÃ¤ÃŸigen Kosten wachsen.

%section{"data-markdown" => ""}
  \### Scope creep
  ist Ã¤hnlich wie der Feature creep, jedoch nicht auf FunktionalitÃ¤t bezogen, sondern auf den
  Anwendungsbereich. Auch hier zeichnet sich der Auftraggeber dadurch aus, dass er geschickt
  und versteckt den Umfang der Software nachtrÃ¤glich erweitern mÃ¶chte, ohne dass er dies
  explizit zugibt.

%section{"data-markdown" => ""}
  \### Death Sprint
  Bei einem Death Sprint (Ãœberhitzter Projektplan) wird Software iterativ bereitgestellt. Die Bereitstellung
  erfolgt hierbei in einer viel zu kurzen Zeitspanne. Nach auÃŸen sieht das Projekt zunÃ¤chst sehr erfolgreich
  aus, da immer wieder neue Versionen mit neuen Eigenschaften abgeschlossen werden. Allerdings leidet die
  QualitÃ¤t des Produktes sowohl nach auÃŸen sichtbar, wie auch technisch, was allerdings nur der
  Entwickler erkennt. Die QualitÃ¤t nimmt ab mit jeder â€žerfolgreichenâ€œ neuen Iteration.

%section{"data-markdown" => ""}
  \### Death March
  Ein Death March (Todesmarsch; gelegentlich auch Himmelfahrtskommando) ist das Gegenteil von einem
  Ãœberhitzten Projektplan. Ein Todesmarschprojekt zieht sich ewig hin.
  %p
  Ein Todesmarschprojekt kann auch bewusst in Kauf genommen werden, um von Defiziten in der
  Organisation abzulenken und Entwicklungen zu verschleppen, d. h. so lange an etwas zu
  entwickeln, bis eine nicht genau spezifizierte Eigenschaft in irgendeiner Form subjektiv funktioniert.

%section{"data-markdown" => ""}
  \### Brooksâ€™sches Gesetz

  \## â€œAdding manpower to a late software project makes it later.â€

%section{"data-markdown" => ""}
  \### Big Ball of Mud
  bezeichnet ein Programm, das keine erkennbare Softwarearchitektur besitzt. Die hÃ¤ufigsten Ursachen dafÃ¼r
  sind ungenÃ¼gende Erfahrung, fehlendes Bewusstsein fÃ¼r Softwarearchitektur, Fluktuation der Mitarbeiter
  sowie Druck auf die Umsetzungsmannschaft. Obwohl derartige Systeme aus WartbarkeitsgrÃ¼nden unerwÃ¼nscht
  sind, sind sie dennoch hÃ¤ufig anzutreffen.

%section{"data-markdown" => ""}
  \### Gasfabrik
  Als Gasfabrik (englisch *Gas factory*) werden unnÃ¶tig komplexe SystementwÃ¼rfe fÃ¼r relativ simple Probleme bezeichnet.

%section{"data-markdown" => ""}
  \### The Blob / Gottobjekt
  Ein Objekt (â€œBlobâ€œ) enthÃ¤lt den GroÃŸteil der Verantwortlichkeiten,
  wÃ¤hrend die meisten anderen Objekte nur elementare Daten speichern oder elementare Dienste anbieten.

%section{"data-markdown" => ""}
  \### Innere-Plattform-Effekt
  tritt auf wenn ein System derartig weitreichende KonfigurationsmÃ¶glichkeiten besitzt, dass es letztlich
  zu einer schwachen Kopie der Plattform wird, mittels derer es gebaut wurde.
  %p
  Ein Beispiel sind Datenmodelle, die auf konkrete (anwendungsbezogene) Datenbanktabellen verzichten
  und stattdessen mittels allgemeiner Tabellen eine eigene Verwaltungsschicht fÃ¼r die Datenstruktur
  implementieren mit dem eigentlichen Ziel, die FlexibilitÃ¤t zu erhÃ¶hen.

%section{"data-markdown" => ""}
  \### Spaghetti Code
  Der Code ist weitgehend unstrukturiert; keine Objektorientierung oder Modularisierung: undurchsichtiger Kontrollfluss.

%section{"data-markdown" => ""}
  \### Sumo-Hochzeit
  Als Sumo-Hochzeit bezeichnet man es, wenn ein Fat Client unnatÃ¼rlich stark abhÃ¤ngig von der Datenbank ist.
  %p
  In der Datenbank ist hierbei sehr viel Logik in Form der datenbankeigenen Programmiersprache positioniert.
  Beispielsweise in Oracle mit der Programmiersprache PL/SQL. Die ganze Architektur ist dadurch sehr unflexibel.

%section{"data-markdown" => ""}
  \### Zwiebel
  Als Zwiebel (engl. Onion) bezeichnet man Programmcode, bei dem neue FunktionalitÃ¤t um (oder Ã¼ber) die alte gelegt wird.
  %p
  HÃ¤ufig entstehen Zwiebeln, wenn ein Entwickler ein Programm erweitern soll, das er nicht geschrieben hat.
  Der Entwickler mÃ¶chte oder kann die bereits existente LÃ¶sung nicht komplett verstehen und setzt seine neue
  LÃ¶sung einfach drÃ¼ber. Dies fÃ¼hrt mit einer Vielzahl von Versionen und unterschiedlichen Entwicklern Ã¼ber
  die Jahre zu einem Zwiebel-System.

%section{"data-markdown" => ""}
  \### Cut-and-Paste Programming
  Code wird an zahlreichen Stellen wiederverwendet, indem er kopiert und verÃ¤ndert wird.
  Dies sorgt fÃ¼r Wartungsprobleme
  \#### LÃ¶sung: Black-Box-Wiederverwendung, Refaktorisierung

%section{"data-markdown" => ""}
  \### Lava Flow
  Ein Lavafluss (englisch Lava flow oder Dead Code) beschreibt den Umstand, dass in einer Anwendung immer mehr
  â€žtoter Quelltextâ€œ herumliegt. Dieser wird nicht mehr genutzt. Statt ihn zu lÃ¶schen, werden im Programm immer
  mehr Verzweigungen eingebaut, die um den besagten Quelltext herumlaufen oder auf ihm aufbauen. Redundanter
  Code ist der Ãœberbegriff zu totem Code.

%section{"data-markdown" => ""}
  \### The Golden Hammer / Wunderwaffe
  Ein bekanntes Verfahren ( Golden â€Hammerâ€œ) wird auf alle moglichen Probleme angewandt
  Wer als einziges Werkzeug nur einen Hammer kennt, lebt in einer Welt voller NÃ¤gel.
  \#### LÃ¶sung: Ausbildung verbessern

%section{"data-markdown" => ""}
  \### Reinvent the Wheel
  Da es an Wissen uber vorhandene Produkte und LÃ¶sungen (auch innerhalb der Firma) fehlt,wird das Rad stets neu erfunden.
  ErhÃ¶hte Entwicklungskosten und Terminprobleme.
  \##### LÃ¶sung: Wissensmanagement verbessern

%section{"data-markdown" => ""}
  \### Das quadratische Rad neu erfinden
  Mit das quadratische Rad neu erfinden (englisch Reinventing the square wheel) bezeichnet man
  die Bereitstellung einer schlechten LÃ¶sung, wenn eine gute LÃ¶sung bereits existiert.

%section{"data-markdown" => ""}
  \### Body ballooning
  Beim Body ballooning handelt der Vorgesetzte ausschlieÃŸlich aus der Bestrebung heraus, seine
  Machtposition auszubauen, welche sich entweder aus der Unternehmensstruktur oder auch rein
  subjektiv aus der Anzahl der Mitarbeiter unter sich definiert. Dies kann dazu fÃ¼hren,
  dass der Vorgesetzte bewusst arbeitsintensivere LÃ¶sungen und Arbeitstechniken den effizienten vorzieht.

%section{"data-markdown" => ""}
  \### Empire building
  Durch sachlich nicht nachvollziehbare, nicht konstruktive MaÃŸnahmen versucht ein einzelner,
  seine Macht auszubauen bzw. zu erhalten. Dies kann Body ballooning sein, aber auch das stÃ¤ndige
  Beschuldigen anderer, gerade derer, die nicht mehr fÃ¼r die Unternehmung arbeiten, die AusfÃ¼hrung von
  pathologischer Politik, Diskreditierung, Mobbing und sonstige Facetten, die nur darauf abzielen,
  die eigene Position zu stÃ¤rken bzw. den eigenen Status zu halten.

%section{"data-markdown" => ""}
  \### Warme Leiche
  Eine warme Leiche (englisch warm body) bezeichnet eine Person, die einen zweifelhaften oder keinen Beitrag zu einem Projekt leistet.

%section{"data-markdown" => ""}
  \### Single head of knowledge
  Ein Single head of knowledge ist ein Individuum, welches zu einer Software, einem Werkzeug oder
  einem anderen eingesetzten Medium, als einziges unternehmensweit das Wissen besitzt. Dies zeugt
  hÃ¤ufig von fehlendem Wissensmanagement, mangelndem Austausch zwischen den Kollegen oder Defiziten in
  der Organisation, kann aber auch von dem Individuum bewusst angestrebt worden sein.

%section{"data-markdown" => ""}
  \### Management nach Zahlen
  (englisch *Management by numbers*) ist eine Anspielung auf Malen nach Zahlen. Beim Management nach Zahlen
  wird ein Ã¼bermÃ¤ÃŸiger Schwerpunkt auf das quantitative Management gelegt. Insbesondere wenn Fokus auf
  Kosten gelegt wird, wÃ¤hrend andere Faktoren wie QualitÃ¤t vernachlÃ¤ssigt werden.

%section{"data-markdown" => ""}
  \### Vendor Lock-In
  Ein System ist weitgehend abhangig von einer proprietaren Architektur oder proprietaren Datenformaten
  \#### LÃ¶sung: PortabilitÃ¤t erhÃ¶hen
  \#### LÃ¶sung: Abstraktionen einfÃ¼hren

%section{"data-markdown" => ""}
  \### Design by Committee
  Das typische Anti-Muster von Standardisierungsgremien, die dazu neigen, es jedem
  Teilnehmer recht zu machen und Ã¼bermÃ¤ÃŸig komplexe EntwÃ¼rfe abzuliefern
  \#### LÃ¶sung: Gruppendynamik und Treffen verbessern

%section{"data-markdown" => ""}
  \### Boat Anchor
  Eine Komponente ohne erkennbaren Nutzen

%section{"data-markdown" => ""}
  \### Dead End
  eingekaufte Komponente, die nicht mehr unterstÃ¼tzt wird

%section{"data-markdown" => ""}
  \### Swiss Army Knife
  Eine Komponente, die vorgibt, alles tun zu kÃ¶nnen


%section{"data-markdown" => ""}
  \##### Hilfreiches Wissen um Anti-Patterns vorzubeugen
  \### "The Pragmatic Programmer"
  *(Andy Hunt, Dave Thomas)*
  \### "Clean Code"
  *(Uncle Bob Martin)*
  \### "The Developers Code"
  *(Ka Wai Cheung)*

%section{"data-markdown" => ""}
  \### Warum sind wir nochmal hier?

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section{"data-markdown" => ""}
  \##### Layers
  Das Layers-Muster trennt eine Architektur in verschiedene Schichten, von denen jede eine Unteraufgabe auf einer bestimmten Abstraktionsebene realisiert.

%section{"data-markdown" => ""}
  \##### Layers
  \### Beispiel: ISO/OSI-Referenzmodell
  Netzwerk-Protokolle sind wahrscheinlich die bekanntesten Beispiele fÃ¼r geschichtete Architekturen.
  Das ISO/OSI-Referenzmodell teilt Netzwerk-Protokolle in 7 Schichten auf, von denen jede Schicht
  fÃ¼r eine bestimmte Aufgabe zustÃ¤ndig ist:

%section{"data-markdown" => ""}
  \##### Beispiel: ISO/OSI-Referenzmodell

  ![](/images/isoosi.png)

%section
  %h5 Layers
  %h4 Aufgabe: Folgendes System bauen:
  %ul
    %li AktivitÃ¤ten auf niederer Ebene wie Hardware-Ansteuerung, Sensoren, Bitverarbeitung
    %li AktivitÃ¤ten auf hoher Ebene wie Planung, Strategien und AnwenderfunktionalitÃ¤t
    %li Die AktivitÃ¤ten auf hoher Ebene werden durch AktivitÃ¤ten der niederen Ebenen realisiert

%section
  %h5 Layers
  %h4 Dabei sollen folgende Ziele berÃ¼cksichtigt werden:
  %ul
    %li Ã„nderungen am Quellcode sollten mÃ¶glichst wenige Ebenen betreffen
    %li Schnittstellen sollten stabil (und mÃ¶glicherweise standardisiert) sein
    %li Teile (= Ebenen) sollten austauschbar sein
    %li Jede Ebene soll separat realisierbar sein


%section{"data-markdown" => ""}
  \##### Layers
  Das Layers-Muster gliedert ein System in zahlreiche Schichten.
  Jede Schicht schÃ¼tzt die unteren Schichten vor direktem Zugriff
  durch hÃ¶here Schichten.

%section{"data-markdown" => ""}
  \##### Layers
  ![](/images/layers.png)


%section{"data-markdown" => ""}
  \##### Layers
  \#### Dynamisches Verhalten

  \### Top-Down Anforderung
  Eine Anforderung des Benutzers wird von der obersten Schicht entgegengenommen.
  Diese resultiert in Anforderungen der unteren Schichten bis hinunter auf die unterste Ebene.
  Ggf. werden die Ergebnisse der unteren Schichten wieder nach oben weitergeleitet, bis das letzte
  Ergebnis an den Benutzer zurÃ¼ckgegeben wird.

%section{"data-markdown" => ""}
  \##### Layers
  \#### Dynamisches Verhalten

  \### Bottom-Up Anforderung
  Hier empfÃ¤ngt die unterste Schicht ein Signal, das an die oberen Schichten weitergeleitet wird.
  SchlieÃŸlich benachrichtigt die oberste Schicht den Benutzer.

%section{"data-markdown" => ""}
  \##### Layers
  \#### Dynamisches Verhalten: Protokoll Stack
  In diesem Szenario kommunizieren zwei n-Schichten-Stacks miteinander.
  Eine Anforderung wandert durch den ersten Stack hinunter, wird Ã¼bertragen und
  schlieÃŸlich als Signal vom zweiten Stack empfangen.
  Jede Schicht verwaltet dabei ihr eigenes Protokoll.

%section{"data-markdown" => ""}
  \##### Layers
  \### Beispiel: TCP/IP

  ![](/images/tcp.png)

%section
  %h5 Layers
  %h3 Vorteile
  %ul
    %li Wiederverwendung und Austauschbarkeit von Schichten
    %li UnterstÃ¼tzung von Standards
    %li Einkapselung von AbhÃ¤ngigkeiten

%section
  %h5 Layers
  %h3 Nachteile
  %ul
    %li Geringere Effizienz
    %li Mehrfache Arbeit (z.B. Fehlerkorrektur)
    %li Schwierigkeit, die richtige Anzahl Schichten zu bestimmen

%section
  %h5 Layers
  %h4 Bekannte Einsatzgebiete:
  %ul
    %li Application Programmer Interfaces (APIs)
    %li Datenbanken
    %li Betriebssysteme
    %li Kommunikation. . .

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \### Pipes und Filter
  \#### Blackboard
  \#### Domain-driven Design

%section
  %h5 Pipes and Filters
  %h4 Eine Pipes-and-Filter Architektur eignet sich fÃ¼r Systeme, die DatenstrÃ¶me verarbeiten.

%section{"data-markdown" => ""}
  \##### Pipes and Filters

  ![](/images/filters1.png)

%section
  %h5 Pipes and Filters

  Das Pipes-and-Filters Muster strukturiert Systeme, in dem Kontext â€žVerarbeitung von
  DatenstrÃ¶menâ€œ. Die Verarbeitungsschritte werden in Filter eingekapselt und lassen sich
  so beliebig anordnen und getrennt voneinander entwickeln.

%section
  %h5 Pipes and Filters
  Der Kommandointerpreter sowie viele Werkzeuge
  des Unix Betriebssystems sind nach dem Pipes-and-
  Filter Muster gebaut. Die Ausgabe des einen dient
  als Eingabe fÃ¼r das nÃ¤chste Werkzeug:

%section
  %h5 Pipes and Filters
  Anzahl Kommentarzeilen in PHP-Datei ausgeben
  %pre
    %code
      :preserve
        cat LocalSettings.php | grep "^ * [#|//]" | wc âˆ’ l

%section
  %h5 Pipes and Filters
  Die fÃ¼nf grÃ¶ÃŸten Dateien ausgeben
  %pre
    %code
      :preserve
        du | sort âˆ’ rn | head âˆ’ 5
%section
  %h5 Pipes and Filters
  Alle Prozesse stoppen, die mit p beginnen
  %pre
    %code
      :preserve
        ps âˆ’ e | grep " p" | awk '{ print $1 }' | xargs kill

%section{"data-markdown" => ""}
  \##### Layers
  \### Beispiel: Compiler

  ![](/images/filters2.png)

%section
  %h5 Pipes and Filters
  %h4 Teilnehmer: Filter
  zustÃ¤ndig fÃ¼r Zusammenarbeit mit Pipe
  %ul
    %li Holt Eingabedaten.
    %li Wendet eine Funktion auf seine Eingabedaten an.
    %li Liefert Ausgabedaten.

%section
  %h5 Pipes and Filters
  %h4 Teilnehmer: Filter
  Ein Filter kann auf dreierlei Weise mit den Daten umgehen:
  %ul
    %li Er kann die Daten anreichern, indem er weitere Informationen berechnet und hinzufÃ¼gt,
    %li Er kann die Daten verfeinern, indem er Information konzentriert oder extrahiert
    %li Er kann die Daten verÃ¤ndern, indem er sie in eine andere Darstellung Ã¼berfÃ¼hrt.

%section
  %h5 Pipes and Filters
  %h4 Teilnehmer: Filter
  Ein Filter kann auf verschiedene Weise aktiv werden:
  %ul
    %li Die folgende Pipeline holt Daten aus dem Filter
    %li Die vorhergehende Pipeline schickt Daten in den Filter
    %li Meistens ist der Filter jedoch selbst aktiv â€“ er holt Daten aus der vorhergehenden Pipeline und schickt Daten in die folgende Pipeline.

%section
  %h5 Pipes and Filters
  %h4 Teilnehmer: Pipe
  %p Eine Pipe verbindet Filter miteinander. Sie verbindet auch die Datenquelle mit dem ersten Filter und den letzten Filter mit der Datensenke.
  %p ZustÃ¤ndig fÃ¼r:
  %ul
    %li Ãœbermittelt Daten
    %li Puffert Daten
    %li Synchronisiert aktive Nachbarn
  %p Verbindet eine Pipe zwei aktive Komponenten, sichert sie die Synchronisation der Filter.


%section
  %h5 Pipes and Filters
  %h4 Teilnehmer: Datenquelle, Datensenke
  %p Diese Komponenten sind die EndstÃ¼cke der Pipeline und somit die Verbindung zur Aussenwelt.
  %p  ZustÃ¤ndig fÃ¼r:
  %ul
    %li Ãœbermittelt Daten an/aus Pipeline.
  %p
    Eine Datenquelle kann entweder aktiv sein (dann reicht sie von sich aus Daten in die Pipeline) oder passiv (dann wartet sie, bis der nÃ¤chste Filter Daten anfordert).
    Analog kann die Datensenke aktiv Daten anfordern oder passiv auf Daten warten.


%section
  %h5 Pipes and Filters
  %h4 Dynamisches Verhalten
  Zwei aktive Filter sind durch eine Pipe verbunden; beide Filter arbeiten parallel.


%section
  %h5 Pipes and Filters
  %h4 Vorteile
  %ul
    %li FlexibilitÃ¤t durch Austausch und HinzufÃ¼gen von Filtern
    %li FlexibilitÃ¤t durch Neuanordnung
    %li Wiederverwendung einzelner Filter
    %li Rapid Prototyping von Pipeline Prototypen
    %li Zwischendateien sind nicht notwendig aber so gewÃ¼nscht mÃ¶glich
    %li Parallel-Verarbeitung mÃ¶glich

%section
  %h5 Pipes and Filters
  %h4 Nachteile
  %ul
    %li Die Kosten der DatenÃ¼bertragung zwischen den Filtern kÃ¶nnen je nach Pipe sehr hoch sein
    %li HÃ¤ufig Ã¼berflÃ¼ssige Datentransformationen zwischen den einzelnen Filterstufen
    %li Fehlerbehandlung Ã¼ber Filterstufen hinweg ist teilweise schwierig
    %li Gemeinsamer Zustand (z.B. Symboltabelle in Compilern) ist teuer und unflexibel
    %li Effizienzsteigerung durch Parallelisierung oft nicht mÃ¶glich (z.B. da Filter aufeinander warten oder nur ein Prozessor arbeitet)

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \### Blackboard
  \#### Domain-driven Design

%section
  %h5 Blackboard

  Das Blackboard Muster wird angewendet bei Problemen, die nicht auf eine eindeutige
  LÃ¶sungsstrategie hindeuten. Den Kontext fÃ¼r â€žBlackboardâ€œ bilden somit Problembereiche,
  fÃ¼r die es noch keine festgelegten LÃ¶sungsstrategien gibt. Beispiele hierfÃ¼r sind
  Spracherkennungs-, Bildverarbeitungs-, sowie Ãœberwachungssysteme.

%section{"data-markdown" => ""}
  \##### Blackboard

  ![](/images/blackboard.png)

%section
  %h5 Blackboard
  Das Schwarzes Brett dient als zentrale Datenstruktur. Agenten verarbeiten vorhandenes und
  bringen neues Wissen. Eine Steuerung entscheidet, welcher Agent die Bedingung zum Ermitteln
  von neuem Wissen erfÃ¼llt und somit das Programm der LÃ¶sung einen Schritt nÃ¤her bringen kÃ¶nnte,
  dann aktiviert es den Agenten.

%section
  %h5 Blackboard
  Die Zugriffe von Agenten auf das schwarze Brett stellen die Konnektoren da. Die Agenten
  sind vÃ¶llig entkoppelt und kÃ¶nnen auch zur Laufzeit hinzugefÃ¼gt und ausgetauscht
  werden, ohne dass andere Agenten betroen sind. Die parallele AusfÃ¼hrung von Agenten ist ebenfalls mÃ¶glich.

%section
  %h5 Blackboard
  Das Programmverhalten von Systemen, fÃ¼r die solch eine Architektur eingesetzt wird, ist
  hochgradig nichtdeterministisch und daher schwer prÃ¼fbar. Im Bereich Robotersteuerung und
  Mustererkennung (Bild, Ton, Sprache, Schrift) wird aufgrund der nichtdeterministischen
  ProblemlÃ¶sung die Black Board Architektur hÃ¤ufig verwendet.

%section{"data-markdown" => ""}
  \##### Chaos zu Struktur / Mud-to-structure
  \#### Layers
  \#### Pipes und Filter
  \#### Blackboard
  \### Domain-driven Design

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design ist nicht nur eine Technik oder Methode. Es ist viel mehr eine Denkweise und
    Priorisierung zur Steigerung der ProduktivitÃ¤t von Softwareprojekten im Umfeld komplexer fachlicher
    ZusammenhÃ¤nge

%section
  %h5 Domain-driven Design
  %p
    Domain-driven Design basiert auf folgenden zwei Annahmen:
  %ul
    %li Der Schwerpunkt des Softwaredesigns liegt auf der Fachlichkeit und der Fachlogik.
    %li Der Entwurf komplexer fachlicher ZusammenhÃ¤nge sollte auf einem Modell der AnwendungsdomÃ¤ne, dem DomÃ¤nenmodell basieren.

%section
  %h5 Domain-driven Design
  %h4 Entwicklungsprozess
  %p
    Domain-driven Design ist an keinen bestimmten Softwareentwicklungsprozess gebunden, orientiert sich aber an agiler Softwareentwicklung.
  %p
    Insbesondere setzt es iterative Softwareentwicklung und eine enge Zusammenarbeit zwischen Entwicklern und Fachexperten voraus.

%section
  %h5 Domain-driven Design
  %h4 Konzepte
  %p
    Domain-driven Design basiert auf einer Reihe von Konzepten, welche bei der Modellierung, aber auch
    anderen TÃ¤tigkeiten der Softwareentwicklung, berÃ¼cksichtigt werden sollten.
  %p
    Der Kern ist die EinfÃ¼hrung einer allgemein verwendeten (ubiquitous) Sprache, welche in allen Bereichen der
    Softwareerstellung verwendet werden sollte.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Sprache
  %p
    Eine Sprache fÃ¼r die Beschreibung der Fachlichkeit, der Elemente des DomÃ¤nenmodells, der Klassen und
    Methoden etc. Sie wird definiert als:
  %p
    *â€œA language structured around the domain model and used by all team members to connect all the activities of the team with the software.â€*

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Bestandteile des DomÃ¤nenmodells
  %p Domain-driven Design unterscheidet die folgenden Bestandteile des DomÃ¤nenmodells:
  %br
  ![](/images/DomainDrivenDesign_map.png)

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### EntitÃ¤ten *(Entities, reference objects)*
  %p
    Objekte des Modelles, welche nicht durch ihre Eigenschaften, sondern durch ihre IdentitÃ¤t definiert werden.
  \#### Beispiel: "Person"

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Wertobjekte *(value objects)*
  %p
    Objekte des Modelles, welche keine konzeptionelle IdentitÃ¤t haben oder benÃ¶tigen und somit allein durch ihre Eigenschaften definiert werden.
  %p
    Wertobjekte werden Ã¼blicherweise als unverÃ¤nderliche Objekte (immutable objects) modelliert, damit sind sie
    wiederverwendbar und verteilbar.
  \#### Beispiel: "Konfiguration"

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Aggregate *(aggregates)*
  %p
    Aggregate sind Zusammenfassungen von EntitÃ¤ten und Wertobjekten und deren Assoziationen untereinander zu
    einer gemeinsamen transaktionalen Einheit.
  %p
    Aggregate definieren genau eine EntitÃ¤t als einzigen Zugriff auf das gesamte Aggregat. Alle anderen
    EntitÃ¤ten und Wertobjekte dÃ¼rfen von auÃŸerhalb nicht statisch referenziert werden. Damit wird garantiert,
    dass alle Invarianten des Aggregats und der einzelnen Bestandteile des Aggregats sichergestellt werden kÃ¶nnen.
  \#### Beispiel: "Datenbanktransaktion"

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Assoziationen *(associations)*
  %p
    Assoziationen sind, wie bei UML definiert, Beziehungen zwischen zwei oder mehr Objekten des DomÃ¤nenmodells.
  %p
    Hier werden nicht nur statische, durch Referenzen definierte Beziehungen betrachtet, sondern auch dynamische
    Beziehungen, die beispielsweise erst durch die Abarbeitung von SQL-Queries entstehen.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Serviceobjekte *(services)*
  %p
    Bei Domain-driven Design werden FunktionalitÃ¤ten, welche ein wichtiges Konzept der Fachlichkeit darstellen und
    konzeptionell zu mehreren Objekten des DomÃ¤nenmodells gehÃ¶ren, als eigenstÃ¤ndige Serviceobjekte modelliert.
  %p
    Serviceobjekte sind Ã¼blicherweise zustandslose (eng. stateless) und daher wiederverwendbare Klassen ohne
    Assoziationen, mit Methoden, die den angebotenen FunktionalitÃ¤ten entsprechen. Diese Methoden bekommen die
    Wertobjekte und EntitÃ¤ten Ã¼bergeben, die zur Abarbeitung der FunktionalitÃ¤t notwendig sind.
  \#### Beispiel: "API Wrapper"

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Fachliche Ereignisse *(domain events)*
  %p
    Fachliche Ereignisse sind Objekte, welche komplexe, sich unter UmstÃ¤nden dynamisch Ã¤ndernde, Aktionen des
    DomÃ¤nenmodells beschreiben, die ein oder mehrere Aktionen oder Ã„nderungen in den Fachobjekten bewirken.
  %p
    Fachliche Ereignisse ermÃ¶glichen auch die Modellierung verteilter Systeme. Die einzelnen Subsysteme
    kommunizieren ausschlieÃŸlich Ã¼ber fachliche Ereignisse, damit werden sie stark entkoppelt und das
    gesamte System somit wartbarer und skalierbarer.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Module *(modules, packages)*
  %p
    Module teilen das DomÃ¤nenmodell in fachliche (nicht technische) Bestandteile. Sie sind gekennzeichnet
    durch starke innere KohÃ¤sion und geringe Kopplung zwischen den Modulen.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Fabriken *(factories)*
  %p
    Fabriken dienen dazu, die Erzeugung von Fachobjekten in spezielle Fabrik-Objekte auszulagern.
  %p
    Dies ist sinnvoll, wenn entweder die Erzeugung komplex ist (und beispielsweise Assoziationen benÃ¶tigt, die
    das Fachobjekt selbst nicht mehr benÃ¶tigt) oder die spezifische Erzeugung der Fachobjekte zur Laufzeit ausgetauscht
    werden kÃ¶nnen soll.
  %p
    *Fabriken werden Ã¼blicherweise durch erzeugende Entwurfsmuster wie abstrakte Fabrik, Fabrikmethode oder Erbauer umgesetzt.*

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Repositories
  %p
    Repositories abstrahieren die Persistierung und Suche von Fachobjekten. Mittels Repositories werden die
    technische Infrastruktur sowie alle Zugriffsmechanismen auf diese von der GeschÃ¤ftslogikschicht getrennt.
  %p
    FÃ¼r alle Fachobjekte, welche Ã¼ber die Infrastruktur-Schicht geladen werden, wird eine Repository-Klasse
    bereitgestellt, welche die verwendeten Lade- und Suchtechnologien nach auÃŸen abkapselt. Die Repositories
    selbst sind Teil des DomÃ¤nenmodells und somit Teil der GeschÃ¤ftslogikschicht. Sie greifen als einzige
    auf die Objekte der Infrastruktur-Schicht zu.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \### Architekturtechniken
  \#### Evolvierende Struktur (evolving order)
  \#### Systemmetapher (system metaphor)
  \#### Verantwortlichkeitsschichten (responsibility layers)
  \#### Wissenslevel (knowledge level)
  \#### Erweiterungsframeworks (pluggable component framework)

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Evolvierende Struktur *(evolving order)*
  GroÃŸe Strukturen im DomÃ¤nenmodell sollten idealerweise erst mit der Zeit entstehen, beziehungsweise sich Ã¼ber die Zeit entwickeln.
  %p
  GroÃŸe Strukturen sollten mÃ¶glichst einfach und mit mÃ¶glichst wenigen Ausnahmen umgesetzt sein.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Systemmetapher *(system metaphor)*
  Die Systemmetapher ist ein Konzept aus Extreme Programming, welche die Kommunikation zwischen allen Beteiligten erleichtert,
  indem es das System mittels einer Metapher, einer inhaltlich Ã¤hnlichen, fÃ¼r alle Seiten verstÃ¤ndlichen Alltagsgeschichte
  beschreibt. Diese sollte mÃ¶glichst gut passen und zur StÃ¤rkung der ubiquitÃ¤ren Sprache verwendet werden.

%section
  %h5 Domain-driven Design
  %h4 Verantwortlichkeitsschichten *(responsibility layers)*
  %p
    Aufteilung des DomÃ¤nenmodells in Schichten gemÃ¤ÃŸ Verantwortlichkeiten.
    Domain-driven Design schlÃ¤gt folgende Schichten vor:
  %ul
    %li Entscheidungsschicht
    %li Regelschicht
    %li Zusagen
    %li ArbeitsablÃ¤ufe
    %li Potential

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Wissenslevel *(knowledge level)*
  %p
    Wissenslevel beschreibt das explizite Wissen Ã¼ber das DomÃ¤nenmodell.
    Es ist in Situationen notwendig, wo die AbhÃ¤ngigkeiten und Rollen zwischen den EntitÃ¤ten
    situationsbedingt variieren.
  %p
    Das Wissenslevel sollte diese AbhÃ¤ngigkeiten und Rollen
    von auÃŸen anpassbar enthalten, damit das DomÃ¤nenmodell weiterhin konkret und ohne
    unnÃ¶tige AbhÃ¤ngigkeiten bleiben kann.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Erweiterungsframeworks *(pluggable component framework)*
  ist die Ãœberlegung verschiedene Systeme Ã¼ber ein Komponentenframework miteinander zu verbinden.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \### Vorgehensweisen
  %p
    Domain-driven Design definiert eine Reihe von Vorgehensweisen, welche dazu dienen die IntegritÃ¤t
    der Modelle zu gewÃ¤hrleisten.
  %p
    Dies ist insbesondere dann notwendig, wenn mehrere Teams unter
    unterschiedlichem Management und Koordination an verschiedenen Fachlichkeiten, aber in einem
    groÃŸen Projekt zusammenarbeiten sollen.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \### Vorgehensweisen
  ![](/images/Maintaining_Model_Integrity.png)

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Vision der Fachlichkeit *(domain vision statement)*
  ist eine kurze Beschreibung der hinter der Kernfachlichkeit stehenden Vision und der damit verbundenen Ziele.
  %p
    Sie gibt die Entwicklungsrichtung des DomÃ¤nenmodells vor und dient als Bindeglied zwischen Projektvision/Systemmetapher
    und den Details der Kernfachlichkeit und des Codes.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### KontextÃ¼bersicht *(context map)*
  dient einer gesamthaften Ãœbersicht Ã¼ber alle Modelle, deren Grenzen und Schnittstellen.
  %p
    Dadurch wachsen die Kontexte nicht
    in Bereiche anderer Kontexte und die Kommunikation zwischen den Kontexten lÃ¤uft Ã¼ber wohldefinierte Schnittstellen.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Kontextgrenzen *(bounded context)*
  beschreiben die Grenzen jedes Kontexts in vielfÃ¤ltiger Hinsicht wie beispielsweise Teamzuordnung, Verwendungszweck,
  dahinter liegende Datenbankschemata.
  %p
    Damit wird klar, wo ein Kontext seine GÃ¼ltigkeit verliert und potentiell ein anderer Kontext seinen Platz einnimmt.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Kernfachlichkeit *(core domain)*
  ist der wertvollste Teil des DomÃ¤nenmodells, der Teil, welcher am meisten Anwendernutzen stiftet.
  %p
    Die anderen Teile des DomÃ¤nenmodells dienen vor allem dazu die Kernfachlichkeit zu unterstÃ¼tzen und mit
    weniger wichtigen Funktionen anzureichern.
  %p
    Bei der Modellierung sollte besonderes Augenmerk auf die
    Kernfachlichkeit gelegt werden und sie sollte durch die besten Entwickler umgesetzt werden.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Geteilter Kern *(shared kernel)*
  ist ein Teil der Fachlichkeit der zwischen unterschiedlichen Projektteilen geteilt wird.
  %p
    Dies ist sinnvoll, wenn die verschiedenen Projektteile nur lose miteinander verbunden sind und
    das Projekt zu groÃŸ ist um in einem Team umgesetzt zu werden. Der geteilte Kern wird hierbei
    von allen Projektteams, die ihn nÃ¼tzen, gemeinsam entwickelt.
  %p *Dies benÃ¶tigt sowohl viel Abstimmungs- als auch Integrationsaufwand.*

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Kunde-Lieferant *(customer-supplier)*
  ist die Metapher fÃ¼r die Beziehung zwischen Projektteams, bei denen ein Team eine Fachlichkeit umsetzt,
  auf die das andere Team aufbaut.
  %p
    Damit wird sichergestellt, dass das abhÃ¤ngige Team vom umsetzenden Team gut unterstÃ¼tzt wird,
    da ihre Anforderungen mit derselben PrioritÃ¤t umgesetzt werden, wie die eigentlichen Anforderungen an das Lieferantenteam.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Separierter Kern *(segregated core)*
  bezeichnet die Ãœberlegung die Kernfachlichkeit, auch wenn sie eng mit unterstÃ¼tzenden Modellelementen gekoppelt ist,
  in ein eigenes Modul zu verlagern und die Kopplung mit anderen Modulen zu reduzieren.
  %p
    Damit wird die Kernfachlichkeit vor hoher KomplexitÃ¤t bewahrt und die Wartbarkeit erhÃ¶ht.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Generische Sub-Fachlichkeiten *(generic subdomains)*
  bezeichnet die Idee, diejenigen Teile des DomÃ¤nenmodells, welche nicht zur Kernfachlichkeit gehÃ¶ren, in Form
  von mÃ¶glichst generischen Modellen in eigenen Modulen abzulegen.
  %p
    Diese kÃ¶nnten, da sie nicht die Kernfachlichkeit reprÃ¤sentieren und generisch sind, outgesourced
    entwickelt oder durch Standardsoftware ersetzt werden.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Kontinuierliche Integration *(continuous integration)*
  dient beim Domain-driven Design dazu, alle VerÃ¤nderungen eines DomÃ¤nenmodells laufend miteinander
  zu integrieren und gegen bestehende Fachlichkeit automatisiert testen zu kÃ¶nnen.

%section{"data-markdown" => ""}
  \##### Domain-driven Design
  \#### Literatur
  \### "Domain-Driven Design. Tackling Complexity in the Heart of Software"
  *(Eric Evans)*

%section{"data-markdown" => ""}
  \## Fragen?

  \##### Unterlagen: [ai2016.nils-loewe.de](https://ai2016.nils-loewe.de)
